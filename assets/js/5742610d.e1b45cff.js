"use strict";(self.webpackChunkfrontend_eng_practices=self.webpackChunkfrontend_eng_practices||[]).push([[114],{1094:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"typescript/language-features","title":"Language features","description":"This section delineates which features may or may not be used, and any additional constraints on their use.","source":"@site/docs/1-typescript/4-language-features.md","sourceDirName":"1-typescript","slug":"/typescript/language-features","permalink":"/frontend-eng-practices/typescript/language-features","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/1-typescript/4-language-features.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Source file structure","permalink":"/frontend-eng-practices/typescript/source-file-structure"},"next":{"title":"Naming","permalink":"/frontend-eng-practices/typescript/naming"}}');var o=s(4848),r=s(8453);const i={sidebar_position:4},a="Language features",l={},c=[{value:"hello",id:"hello",level:2},{value:"hello1",id:"hello1",level:3},{value:"hello2",id:"hello2",level:3},{value:"hello3",id:"hello3",level:3},{value:"hello4",id:"hello4",level:3},{value:"Equality checks",id:"equality-checks",level:3},{value:"Type and non-nullability assertions",id:"type-and-non-nullability-assertions",level:3},{value:"Keep try blocks focused",id:"keep-try-blocks-focused",level:3},{value:"Decorators",id:"decorators",level:2},{value:"Disallowed features",id:"disallowed-features",level:2},{value:"Wrapper objects for primitive types",id:"wrapper-objects-for-primitive-types",level:3},{value:"Automatic Semicolon Insertion",id:"automatic-semicolon-insertion",level:3},{value:"Const enums",id:"const-enums",level:3},{value:"Debugger statements",id:"debugger-statements",level:3},{value:"<code>with</code>",id:"with",level:3},{value:"Dynamic code evaluation",id:"dynamic-code-evaluation",level:3},{value:"Non-standard features",id:"non-standard-features",level:3},{value:"Modifying builtin objects",id:"modifying-builtin-objects",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"language-features",children:"Language features"})}),"\n",(0,o.jsx)(n.p,{children:"This section delineates which features may or may not be used, and any additional constraints on their use.\nLanguage features which are not discussed in this style guide may be used with no recommendations of their usage."}),"\n",(0,o.jsx)(n.h2,{id:""}),"\n",(0,o.jsx)(n.h2,{id:"-1"}),"\n",(0,o.jsx)(n.h2,{id:"-2"}),"\n",(0,o.jsx)(n.h2,{id:"-3"}),"\n",(0,o.jsx)(n.h2,{id:"-4"}),"\n",(0,o.jsx)(n.h2,{id:"-5"}),"\n",(0,o.jsx)(n.h2,{id:"-6"}),"\n",(0,o.jsx)(n.h2,{id:"-7"}),"\n",(0,o.jsx)(n.h2,{id:"hello",children:"hello"}),"\n",(0,o.jsx)(n.h3,{id:"hello1",children:"hello1"}),"\n",(0,o.jsx)(n.h3,{id:"hello2",children:"hello2"}),"\n",(0,o.jsx)(n.h3,{id:"hello3",children:"hello3"}),"\n",(0,o.jsx)(n.h3,{id:"hello4",children:"hello4"}),"\n",(0,o.jsx)(n.h3,{id:"equality-checks",children:"Equality checks"}),"\n",(0,o.jsxs)(n.p,{children:["Always use triple equals (",(0,o.jsx)(n.code,{children:"==="}),") and not equals (",(0,o.jsx)(n.code,{children:"!=="}),"). The double equality operators cause error prone type coercions that are hard to understand and slower to implement for JavaScript Virtual Machines. See also the JavaScript equality table."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'if (foo == "bar" || baz != bam) {\n  // Hard to understand behaviour due to type coercion.\n}\nif (foo === "bar" || baz !== bam) {\n  // All good here.\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Exception: Comparisons to the literal null value may use the == and != operators to cover both null and undefined values."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"if (foo == null) {\n  // Will trigger when foo is null or undefined.\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"type-and-non-nullability-assertions",children:"Type and non-nullability assertions"}),"\n",(0,o.jsxs)(n.p,{children:["Type assertions (",(0,o.jsx)(n.code,{children:"x as SomeType"}),") and non-nullability assertions (",(0,o.jsx)(n.code,{children:"y!"}),") are unsafe. Both only silence the TypeScript compiler, but do not insert any runtime checks to match these assertions, so they can cause your program to crash at runtime."]}),"\n",(0,o.jsx)(n.p,{children:"Because of this, you should not use type and non-nullability assertions without an obvious or explicit reason for doing so."}),"\n",(0,o.jsx)(n.p,{children:"Instead of the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"(x as Foo).foo();\n\ny!.bar();\n"})}),"\n",(0,o.jsx)(n.p,{children:"When you want to assert a type or non-nullability the best answer is to explicitly write a runtime check that performs that check."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// assuming Foo is a class.\nif (x instanceof Foo) {\n  x.foo();\n}\n\nif (y) {\n  y.bar();\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Sometimes due to some local property of your code you can be sure that the assertion form is safe. In those situations, you should add clarification to explain why you are ok with the unsafe behavior:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// x is a Foo, because ...\n(x as Foo).foo();\n\n// y cannot be null, because ...\ny!.bar();\n"})}),"\n",(0,o.jsx)(n.p,{children:"If the reasoning behind a type or non-nullability assertion is obvious, the comments may not be necessary. For example, generated proto code is always nullable, but perhaps it is well-known in the context of the code that certain fields are always provided by the backend. Use your judgement."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Type assertion syntax"}),"\nType assertions must use the ",(0,o.jsx)(n.code,{children:"as"})," syntax (as opposed to the angle brackets syntax). This enforces parentheses around the assertion when accessing a member."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const x = (<Foo>z).length;\nconst y = <Foo>z.length;\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// z must be Foo because ...\nconst x = (z as Foo).length;\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Double assertions"}),"\nFrom the TypeScript handbook, TypeScript only allows type assertions which convert to a more specific or less specific version of a type. Adding a type assertion (",(0,o.jsx)(n.code,{children:"x as Foo"}),") which does not meet this criteria will give the error: Conversion of type 'X' to type 'Y' may be a mistake because neither type sufficiently overlaps with the other."]}),"\n",(0,o.jsxs)(n.p,{children:["If you are sure an assertion is safe, you can perform a double assertion. This involves casting through ",(0,o.jsx)(n.code,{children:"unknown"})," since it is less specific than all types."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// x is a Foo here, because...\n(x as unknown as Foo).fooMethod();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"unknown"})," (instead of ",(0,o.jsx)(n.code,{children:"any"})," or ",(0,o.jsx)(n.code,{children:"{}"}),") as the intermediate type."]}),"\n",(0,o.jsxs)(n.p,{children:["Type assertions and object literals\nUse type annotations (",(0,o.jsx)(n.code,{children:": Foo"}),") instead of type assertions (",(0,o.jsx)(n.code,{children:"as Foo"}),") to specify the type of an object literal. This allows detecting refactoring bugs when the fields of an interface change over time."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'interface Foo {\n  bar: number;\n  baz?: string; // was "bam", but later renamed to "baz".\n}\n\nconst foo = {\n  bar: 123,\n  bam: "abc", // no error!\n} as Foo;\n\nfunction func() {\n  return {\n    bar: 123,\n    bam: "abc", // no error!\n  } as Foo;\n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'interface Foo {\n  bar: number;\n  baz?: string;\n}\n\nconst foo: Foo = {\n  bar: 123,\n  bam: "abc", // complains about "bam" not being defined on Foo.\n};\n\nfunction func(): Foo {\n  return {\n    bar: 123,\n    bam: "abc", // complains about "bam" not being defined on Foo.\n  };\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"keep-try-blocks-focused",children:"Keep try blocks focused"}),"\n",(0,o.jsx)(n.p,{children:"Limit the amount of code inside a try block, if this can be done without hurting readability."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"try {\n  const result = methodThatMayThrow();\n  use(result);\n} catch (error: unknown) {\n  // ...\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"let result;\ntry {\n  result = methodThatMayThrow();\n} catch (error: unknown) {\n  // ...\n}\nuse(result);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Moving the non-throwable lines out of the try/catch block helps the reader learn which method throws exceptions. Some inline calls that do not throw exceptions could stay inside because they might not be worth the extra complication of a temporary variable."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Exception"}),": There may be performance issues if try blocks are inside a loop. Widening try blocks to cover a whole loop is ok."]}),"\n",(0,o.jsx)(n.h2,{id:"decorators",children:"Decorators"}),"\n",(0,o.jsxs)(n.p,{children:["Decorators are syntax with an ",(0,o.jsx)(n.code,{children:"@"})," prefix, like ",(0,o.jsx)(n.code,{children:"@MyDecorator"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Do not define new decorators. Only use the decorators defined by frameworks:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Angular (e.g. ",(0,o.jsx)(n.code,{children:"@Component"}),", ",(0,o.jsx)(n.code,{children:"@Injectable"}),", etc.)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Why?"}),"\n",(0,o.jsx)(n.p,{children:"We generally want to avoid decorators, because they were an experimental feature that have since diverged from the TC39 proposal and have known bugs that won't be fixed."}),"\n",(0,o.jsx)(n.p,{children:"When using decorators, the decorator must immediately precede the symbol it decorates, with no empty lines between:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"/** JSDoc comments go before decorators */\n@Component({...})  // Note: no empty line after the decorator.\nclass MyComp {\n  @Input() myField: string;  // Decorators on fields may be on the same line...\n\n  @Input()\n  myOtherField: string;  // ... or wrap.\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"disallowed-features",children:"Disallowed features"}),"\n",(0,o.jsx)(n.h3,{id:"wrapper-objects-for-primitive-types",children:"Wrapper objects for primitive types"}),"\n",(0,o.jsxs)(n.p,{children:["TypeScript code must not instantiate the wrapper classes for the primitive types ",(0,o.jsx)(n.code,{children:"String"}),", ",(0,o.jsx)(n.code,{children:"Boolean"}),", and ",(0,o.jsx)(n.code,{children:"Number"}),". Wrapper classes have surprising behavior, such as ",(0,o.jsx)(n.code,{children:"new Boolean(false)"})," evaluating to ",(0,o.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'const s = new String("hello");\nconst b = new Boolean(false);\nconst n = new Number(5);\n'})}),"\n",(0,o.jsx)(n.p,{children:"The wrappers may be called as functions for coercing (which is preferred over using + or concatenating the empty string) or creating symbols. See type coercion for more information."}),"\n",(0,o.jsx)(n.h3,{id:"automatic-semicolon-insertion",children:"Automatic Semicolon Insertion"}),"\n",(0,o.jsx)(n.p,{children:"Do not rely on Automatic Semicolon Insertion (ASI). Explicitly end all statements using a semicolon. This prevents bugs due to incorrect semicolon insertions and ensures compatibility with tools with limited ASI support (e.g. clang-format)."}),"\n",(0,o.jsx)(n.h3,{id:"const-enums",children:"Const enums"}),"\n",(0,o.jsxs)(n.p,{children:["Code must not use ",(0,o.jsx)(n.code,{children:"const enum;"})," use plain ",(0,o.jsx)(n.code,{children:"enum"})," instead."]}),"\n",(0,o.jsx)(n.p,{children:"Why?"}),"\n",(0,o.jsxs)(n.p,{children:["TypeScript enums already cannot be mutated; ",(0,o.jsx)(n.code,{children:"const enum"})," is a separate language feature related to optimization that makes the enum invisible to JavaScript users of the module."]}),"\n",(0,o.jsx)(n.h3,{id:"debugger-statements",children:"Debugger statements"}),"\n",(0,o.jsx)(n.p,{children:"Debugger statements must not be included in production code."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function debugMe() {\n  debugger;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"with",children:(0,o.jsx)(n.code,{children:"with"})}),"\n",(0,o.jsxs)(n.p,{children:["Do not use the ",(0,o.jsx)(n.code,{children:"with"})," keyword. It makes your code harder to understand and has been banned in strict mode since ES5."]}),"\n",(0,o.jsx)(n.h3,{id:"dynamic-code-evaluation",children:"Dynamic code evaluation"}),"\n",(0,o.jsxs)(n.p,{children:["Do not use ",(0,o.jsx)(n.code,{children:"eval"})," or the ",(0,o.jsx)(n.code,{children:"Function(...string)"})," constructor (except for code loaders). These features are potentially dangerous and simply do not work in environments using strict Content Security Policies."]}),"\n",(0,o.jsx)(n.h3,{id:"non-standard-features",children:"Non-standard features"}),"\n",(0,o.jsx)(n.p,{children:"Do not use non-standard ECMAScript or Web Platform features."}),"\n",(0,o.jsx)(n.p,{children:"This includes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Old features that have been marked deprecated or removed entirely from ECMAScript / the Web Platform (see MDN)"}),"\n",(0,o.jsx)(n.li,{children:"New ECMAScript features that are not yet standardized"}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Avoid using features that are in current TC39 working draft or currently in the proposal process"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Use only ECMAScript features defined in the current ECMA-262 specification"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Proposed but not-yet-complete web standards:"}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"WHATWG proposals that have not completed the proposal process."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Non-standard language \u201cextensions\u201d (such as those provided by some external transpilers)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Projects targeting specific JavaScript runtimes, such as latest-Chrome-only, Chrome extensions, Node.JS, Electron, can obviously use those APIs. Use caution when considering an API surface that is proprietary and only implemented in some browsers; consider whether there is a common library that can abstract this API surface away for you."}),"\n",(0,o.jsx)(n.h3,{id:"modifying-builtin-objects",children:"Modifying builtin objects"}),"\n",(0,o.jsx)(n.p,{children:"Never modify builtin types, either by adding methods to their constructors or to their prototypes. Avoid depending on libraries that do this."}),"\n",(0,o.jsx)(n.p,{children:"Do not add symbols to the global object unless absolutely necessary (e.g. required by a third-party API)."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var t=s(6540);const o={},r=t.createContext(o);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);