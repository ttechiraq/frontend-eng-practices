"use strict";(self.webpackChunkfrontend_eng_practices=self.webpackChunkfrontend_eng_practices||[]).push([[114],{1094:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"typescript/language-features","title":"Language features","description":"This section delineates which features may or may not be used, and any additional constraints on their use.","source":"@site/docs/1-typescript/4-language-features.md","sourceDirName":"1-typescript","slug":"/typescript/language-features","permalink":"/frontend-eng-practices/typescript/language-features","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/1-typescript/4-language-features.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Source file structure","permalink":"/frontend-eng-practices/typescript/source-file-structure"},"next":{"title":"Naming","permalink":"/frontend-eng-practices/typescript/naming"}}');var i=s(4848),r=s(8453);const o={sidebar_position:4},a="Language features",l={},c=[{value:"Local variable declarations",id:"local-variable-declarations",level:2},{value:"Use const and let",id:"use-const-and-let",level:3},{value:"One variable per declaration",id:"one-variable-per-declaration",level:3},{value:"Array literals",id:"array-literals",level:2},{value:"Do not use the Array constructor",id:"do-not-use-the-array-constructor",level:3},{value:"Do not define properties on arrays",id:"do-not-define-properties-on-arrays",level:3},{value:"Using spread syntax",id:"using-spread-syntax",level:3},{value:"Array destructuring",id:"array-destructuring",level:3},{value:"Object literals",id:"object-literals",level:2},{value:"Do not use the Object constructor",id:"do-not-use-the-object-constructor",level:3},{value:"Iterating objects",id:"iterating-objects",level:3},{value:"Using spread syntax",id:"using-spread-syntax-1",level:3},{value:"Computed property names",id:"computed-property-names",level:3},{value:"Object destructuring",id:"object-destructuring",level:3},{value:"Class members",id:"class-members",level:3},{value:"No #private fields",id:"no-private-fields",level:4},{value:"Use readonly",id:"use-readonly",level:4},{value:"Parameter properties",id:"parameter-properties",level:4},{value:"Field initializers",id:"field-initializers",level:4},{value:"Properties used outside of class lexical scope",id:"properties-used-outside-of-class-lexical-scope",level:4},{value:"Getters and setters",id:"getters-and-setters",level:4},{value:"Computed properties",id:"computed-properties",level:4},{value:"Visibility",id:"visibility",level:4},{value:"Disallowed class patterns",id:"disallowed-class-patterns",level:4},{value:"Do not manipulate prototypes directly",id:"do-not-manipulate-prototypes-directly",level:4},{value:"Interfaces",id:"interfaces",level:2},{value:"Primitive literals",id:"primitive-literals",level:3},{value:"String literals",id:"string-literals",level:4},{value:"Use single quotes",id:"use-single-quotes",level:5},{value:"No line continuations",id:"no-line-continuations",level:5},{value:"Template literals",id:"template-literals",level:5},{value:"Number literals",id:"number-literals",level:4},{value:"Type coercion",id:"type-coercion",level:3},{value:"Implicit coercion",id:"implicit-coercion",level:3},{value:"Functions",id:"functions",level:2},{value:"Terminology",id:"terminology",level:3},{value:"Prefer function declarations for named functions",id:"prefer-function-declarations-for-named-functions",level:3},{value:"Nested functions",id:"nested-functions",level:3},{value:"Do not use function expressions",id:"do-not-use-function-expressions",level:3},{value:"Arrow function bodies",id:"arrow-function-bodies",level:3},{value:"Rebinding this",id:"rebinding-this",level:3},{value:"Prefer passing arrow functions as callbacks",id:"prefer-passing-arrow-functions-as-callbacks",level:3},{value:"Arrow functions as properties",id:"arrow-functions-as-properties",level:3},{value:"Event handlers",id:"event-handlers",level:3},{value:"Parameter initializers",id:"parameter-initializers",level:3},{value:"Prefer rest and spread when appropriate",id:"prefer-rest-and-spread-when-appropriate",level:3},{value:"Formatting functions",id:"formatting-functions",level:3},{value:"this",id:"this",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"language-features",children:"Language features"})}),"\n",(0,i.jsx)(n.p,{children:"This section delineates which features may or may not be used, and any additional constraints on their use."}),"\n",(0,i.jsx)(n.p,{children:"Language features which are not discussed in this style guide may be used with no recommendations of their usage."}),"\n",(0,i.jsx)(n.h2,{id:"local-variable-declarations",children:"Local variable declarations"}),"\n",(0,i.jsx)(n.h3,{id:"use-const-and-let",children:"Use const and let"}),"\n",(0,i.jsxs)(n.p,{children:["Always use ",(0,i.jsx)(n.code,{children:"const"})," or ",(0,i.jsx)(n.code,{children:"let"})," to declare variables. Use ",(0,i.jsx)(n.code,{children:"const"})," by default, unless a variable needs to be reassigned. Never use ",(0,i.jsx)(n.code,{children:"var"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const foo = otherValue;  // Use if "foo" never changes.\nlet bar = someValue;     // Use if "bar" is ever assigned into later on.\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"const"})," and ",(0,i.jsx)(n.code,{children:"let"})," are block scoped, like variables in most other languages. ",(0,i.jsx)(n.code,{children:"var"})," in JavaScript is function scoped, which can cause difficult to understand bugs. Don't use it."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Don't use - var scoping is complex and causes bugs.\nvar foo = someValue;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Variables must not be used before their declaration."}),"\n",(0,i.jsx)(n.h3,{id:"one-variable-per-declaration",children:"One variable per declaration"}),"\n",(0,i.jsxs)(n.p,{children:["Every local variable declaration declares only one variable: declarations such as ",(0,i.jsx)(n.code,{children:"let a = 1, b = 2;"})," are not used."]}),"\n",(0,i.jsx)(n.h2,{id:"array-literals",children:"Array literals"}),"\n",(0,i.jsx)(n.h3,{id:"do-not-use-the-array-constructor",children:"Do not use the Array constructor"}),"\n",(0,i.jsxs)(n.p,{children:["Do not use the ",(0,i.jsx)(n.code,{children:"Array()"})," constructor, with or without ",(0,i.jsx)(n.code,{children:"new"}),". It has confusing and contradictory usage:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const a = new Array(2);     // [undefined, undefined]\nconst b = new Array(2, 3);  // [2, 3];\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Instead, always use bracket notation to initialize arrays, or ",(0,i.jsx)(n.code,{children:"from"})," to initialize an ",(0,i.jsx)(n.code,{children:"Array"})," with a certain size:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const a = [2];\nconst b = [2, 3];\n\n// Equivalent to Array(2):\nconst c = [];\nc.length = 2;\n\n// [0, 0, 0, 0, 0]\nArray.from<number>({length: 5}).fill(0);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"do-not-define-properties-on-arrays",children:"Do not define properties on arrays"}),"\n",(0,i.jsxs)(n.p,{children:["Do not define or use non-numeric properties on an array (other than ",(0,i.jsx)(n.code,{children:"length"}),"). Use a ",(0,i.jsx)(n.code,{children:"Map"})," (or ",(0,i.jsx)(n.code,{children:"Object"}),") instead."]}),"\n",(0,i.jsx)(n.h3,{id:"using-spread-syntax",children:"Using spread syntax"}),"\n",(0,i.jsxs)(n.p,{children:["Using spread syntax ",(0,i.jsx)(n.code,{children:"[...foo];"})," is a convenient shorthand for shallow-copying or concatenating iterables."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const foo = [1,];\nconst foo2 = [...foo, 6, 7,];\nconst foo3 = [5, ...foo,];\nfoo2[1] === 6;\nfoo3[1] === 1;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When using spread syntax, the value being spread must match what is being created. When creating an array, only spread iterables. Primitives (including ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"undefined"}),") must not be spread."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nconst foo = [7];\nconst bar = [5, ...(shouldUseFoo && foo)]; // might be undefined\n\n// Creates {0: 'a', 1: 'b', 2: 'c'} but has no length\nconst fooStrings = ['a', 'b', 'c'];\nconst ids = {...fooStrings};\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nconst foo = shouldUseFoo ? [7] : [];\nconst bar = [5, ...foo];\nconst fooStrings = ['a', 'b', 'c'];\nconst ids = [...fooStrings, 'd', 'e'];\n"})}),"\n",(0,i.jsx)(n.h3,{id:"array-destructuring",children:"Array destructuring"}),"\n",(0,i.jsxs)(n.p,{children:["Array literals may be used on the left-hand side of an assignment to perform destructuring (such as when unpacking multiple values from a single array or iterable). A final rest element may be included (with no space between the ",(0,i.jsx)(n.code,{children:"..."})," and the variable name). Elements should be omitted if they are unused."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const [a, b, c, ...rest] = generateResults();\nlet [, b,, d] = someArray;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Destructuring may also be used for function parameters. Always specify ",(0,i.jsx)(n.code,{children:"[]"})," as the default value if a destructured array parameter is optional, and provide default values on the left hand side:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function destructured([a = 4, b = 2] = []) { \u2026 }\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Disallowed:\nfunction badDestructuring([a, b] = [4, 2]) { \u2026 }\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tip:"})," For (un)packing multiple values into a function's parameter or return, prefer object destructuring to array destructuring when possible, as it allows naming the individual elements and specifying a different type for each."]}),"\n",(0,i.jsx)(n.h2,{id:"object-literals",children:"Object literals"}),"\n",(0,i.jsx)(n.h3,{id:"do-not-use-the-object-constructor",children:"Do not use the Object constructor"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Object"})," constructor is disallowed. Use an object literal (",(0,i.jsx)(n.code,{children:"{}"})," or ",(0,i.jsx)(n.code,{children:"{a: 0, b: 1, c: 2}"}),") instead."]}),"\n",(0,i.jsx)(n.h3,{id:"iterating-objects",children:"Iterating objects"}),"\n",(0,i.jsxs)(n.p,{children:["Iterating objects with ",(0,i.jsx)(n.code,{children:"for (... in ...)"})," is error prone. It will include enumerable properties from the prototype chain."]}),"\n",(0,i.jsxs)(n.p,{children:["Do not use unfiltered ",(0,i.jsx)(n.code,{children:"for (... in ...)"})," statements:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nfor (const x in someObj) {\n  // x could come from some parent prototype!\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Either filter values explicitly with an ",(0,i.jsx)(n.code,{children:"if"})," statement, or use ",(0,i.jsx)(n.code,{children:"for (... of Object.keys(...))"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nfor (const x in someObj) {\n  if (!someObj.hasOwnProperty(x)) continue;\n  // now x was definitely defined on someObj\n}\nfor (const x of Object.keys(someObj)) { // note: for _of_!\n  // now x was definitely defined on someObj\n}\nfor (const [key, value] of Object.entries(someObj)) { // note: for _of_!\n  // now key was definitely defined on someObj\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"using-spread-syntax-1",children:"Using spread syntax"}),"\n",(0,i.jsxs)(n.p,{children:["Using spread syntax ",(0,i.jsx)(n.code,{children:"{...bar}"})," is a convenient shorthand for creating a shallow copy of an object. When using spread syntax in object initialization, later values replace earlier values at the same key."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const foo = { num: 1, };\nconst foo2 = { ...foo, num: 5, };\nconst foo3 = { num: 5, ...foo, }\nfoo2.num === 5;\nfoo3.num === 1;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When using spread syntax, the value being spread must match what is being created. That is, when creating an object, only objects may be spread; arrays and primitives (including ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"undefined"}),") must not be spread. Avoid spreading objects that have prototypes other than the Object prototype (e.g. class definitions, class instances, functions) as the behavior is unintuitive (only enumerable non-prototype properties are shallow-copied)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nconst foo = {num: 7};\nconst bar = {num: 5, ...(shouldUseFoo && foo)}; // might be undefined\n\n// Creates {0: 'a', 1: 'b', 2: 'c'} but has no length\nconst fooStrings = ['a', 'b', 'c'];\nconst ids = {...fooStrings};\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nconst foo = shouldUseFoo ? {num: 7} : {};\nconst bar = {num: 5, ...foo};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"computed-property-names",children:"Computed property names"}),"\n",(0,i.jsxs)(n.p,{children:["Computed property names (e.g. ",(0,i.jsx)(n.code,{children:"{['key' + foo()]: 42}"}),") are allowed, and are considered dict-style (quoted) keys (i.e., must not be mixed with non-quoted keys) unless the computed property is a ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",children:"symbol"})," (e.g. ",(0,i.jsx)(n.code,{children:"[Symbol.iterator]"}),")."]}),"\n",(0,i.jsx)(n.h3,{id:"object-destructuring",children:"Object destructuring"}),"\n",(0,i.jsx)(n.p,{children:"Object destructuring patterns may be used on the left-hand side of an assignment to perform destructuring and unpack multiple values from a single object."}),"\n",(0,i.jsxs)(n.p,{children:["Destructured objects may also be used as function parameters, but should be kept as simple as possible: a single level of unquoted shorthand properties. Deeper levels of nesting and computed properties may not be used in parameter destructuring. Specify any default values in the left-hand-side of the destructured parameter (",(0,i.jsx)(n.code,{children:"{str = 'some default'} = {}"}),", rather than ",(0,i.jsx)(n.code,{children:"{str} = {str: 'some default'}"}),"), and if a destructured object is itself optional, it must default to ",(0,i.jsx)(n.code,{children:"{}"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface Options {\n  /** The number of times to do something. */\n  num?: number;\n  /** A string to do stuff to. */\n  str?: string;\n}\n\nfunction destructured({num, str = 'default'}: Options = {}) {}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Disallowed:\nfunction nestedTooDeeply({x: {num, str}}: {x: Options}) {}\nfunction nontrivialDefault({num, str}: Options = {num: 42, str: 'default'}) {}\n``` ctorParam) {}\n  doThing() {\n    console.log(ctorParam.getThing() + myField);\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"class-members",children:"Class members"}),"\n",(0,i.jsx)(n.h4,{id:"no-private-fields",children:"No #private fields"}),"\n",(0,i.jsx)(n.p,{children:"Do not use private fields (also known as private identifiers):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nclass Clazz {\n  #ident = 1;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Instead, use TypeScript's visibility annotations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nclass Clazz {\n  private ident = 1;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why?"})}),"\n",(0,i.jsx)(n.p,{children:"Private identifiers cause substantial emit size and performance regressions when down-leveled by TypeScript, and are unsupported before ES2015. They can only be downleveled to ES2015, not lower. At the same time, they do not offer substantial benefits when static type checking is used to enforce visibility."}),"\n",(0,i.jsx)(n.h4,{id:"use-readonly",children:"Use readonly"}),"\n",(0,i.jsxs)(n.p,{children:["Mark properties that are never reassigned outside of the constructor with the ",(0,i.jsx)(n.code,{children:"readonly"})," modifier (these need not be deeply immutable)."]}),"\n",(0,i.jsx)(n.h4,{id:"parameter-properties",children:"Parameter properties"}),"\n",(0,i.jsxs)(n.p,{children:["Rather than plumbing an obvious initializer through to a class member, use a TypeScript ",(0,i.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties",children:"parameter property"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nclass Foo {\n  private readonly barService: BarService;\n  constructor(barService: BarService) {\n    this.barService = barService;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nclass Foo {\n  constructor(private readonly barService: BarService) {}\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If the parameter property needs documentation, use an ",(0,i.jsx)(n.code,{children:"@param"})," JSDoc tag."]}),"\n",(0,i.jsx)(n.h4,{id:"field-initializers",children:"Field initializers"}),"\n",(0,i.jsx)(n.p,{children:"If a class member is not a parameter, initialize it where it's declared, which sometimes lets you drop the constructor entirely."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nclass Foo {\n  private readonly userList: string[];\n  constructor() {\n    this.userList = [];\n  }\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nclass Foo {\n  private readonly userList: string[] = [];\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tip:"})," Properties should never be added to or removed from an instance after the constructor is finished, since it significantly hinders VMs' ability to optimize classes' shape. Optional fields that may be filled in later should be explicitly initialized to ",(0,i.jsx)(n.code,{children:"undefined"})," to prevent later shape changes."]}),"\n",(0,i.jsx)(n.h4,{id:"properties-used-outside-of-class-lexical-scope",children:"Properties used outside of class lexical scope"}),"\n",(0,i.jsxs)(n.p,{children:["Properties used from outside the lexical scope of their containing class, such as an Angular component's properties used from a template, must not use ",(0,i.jsx)(n.code,{children:"private"})," visibility, as they are used outside of the lexical scope of their containing class."]}),"\n",(0,i.jsxs)(n.p,{children:["Use either ",(0,i.jsx)(n.code,{children:"protected"})," or ",(0,i.jsx)(n.code,{children:"public"})," as appropriate to the property in question. Angular and AngularJS template properties should use ",(0,i.jsx)(n.code,{children:"protected"}),", but Polymer should use ",(0,i.jsx)(n.code,{children:"public"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["TypeScript code must not use ",(0,i.jsx)(n.code,{children:"obj['foo']"})," to bypass the visibility of a property."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why?"})}),"\n",(0,i.jsxs)(n.p,{children:["When a property is ",(0,i.jsx)(n.code,{children:"private"}),", you are declaring to both automated systems and humans that the property accesses are scoped to the methods of the declaring class, and they will rely on that. For example, a check for unused code will flag a private property that appears to be unused, even if some other file manages to bypass the visibility restriction."]}),"\n",(0,i.jsxs)(n.p,{children:["Though it might appear that ",(0,i.jsx)(n.code,{children:"obj['foo']"})," can bypass visibility in the TypeScript compiler, this pattern can be broken by rearranging the build rules, and also violates optimization compatibility."]}),"\n",(0,i.jsx)(n.h4,{id:"getters-and-setters",children:"Getters and setters"}),"\n",(0,i.jsxs)(n.p,{children:["Getters and setters, also known as accessors, for class members may be used. The getter method must be a ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Pure_function",children:"pure function"})," (i.e., result is consistent and has no side effects: getters must not change observable state). They are also useful as a means of restricting the visibility of internal or verbose implementation details (shown below)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nclass Foo {\n  constructor(private readonly someService: SomeService) {}\n  get someMember(): string {\n    return this.someService.someVariable;\n  }\n  set someMember(newValue: string) {\n    this.someService.someVariable = newValue;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nclass Foo {\n  nextId = 0;\n  get next() {\n    return this.nextId++; // Bad: getter changes observable state\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If an accessor is used to hide a class property, the hidden property may be prefixed or suffixed with any whole word, like ",(0,i.jsx)(n.code,{children:"internal"})," or ",(0,i.jsx)(n.code,{children:"wrapped"}),". When using these private properties, access the value through the accessor whenever possible. At least one accessor for a property must be non-trivial: do not define pass-through accessors only for the purpose of hiding a property. Instead, make the property public (or consider making it ",(0,i.jsx)(n.code,{children:"readonly"})," rather than just defining a getter with no setter)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nclass Foo {\n  private wrappedBar = '';\n  get bar() {\n    return this.wrappedBar || 'bar';\n  }\n  set bar(wrapped: string) {\n    this.wrappedBar = wrapped.trim();\n  }\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nclass Bar {\n  private barInternal = '';\n  // Neither of these accessors have logic, so just make bar public.\n  get bar() {\n    return this.barInternal;\n  }\n  set bar(value: string) {\n    this.barInternal = value;\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Getters and setters must not be defined using ",(0,i.jsx)(n.code,{children:"Object.defineProperty"}),", since this interferes with property renaming."]}),"\n",(0,i.jsx)(n.h4,{id:"computed-properties",children:"Computed properties"}),"\n",(0,i.jsxs)(n.p,{children:["Computed properties may only be used in classes when the property is a symbol. Dict-style properties (that is, quoted or computed non-symbol keys) are not allowed. A ",(0,i.jsx)(n.code,{children:"[Symbol.iterator]"})," method should be defined for any classes that are logically iterable. Beyond this, ",(0,i.jsx)(n.code,{children:"Symbol"})," should be used sparingly."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tip:"})," be careful of using any other built-in symbols (e.g. ",(0,i.jsx)(n.code,{children:"Symbol.isConcatSpreadable"}),") as they are not polyfilled by the compiler and will therefore not work in older browsers."]}),"\n",(0,i.jsx)(n.h4,{id:"visibility",children:"Visibility"}),"\n",(0,i.jsx)(n.p,{children:"Restricting visibility of properties, methods, and entire types helps with keeping code decoupled."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Limit symbol visibility as much as possible."}),"\n",(0,i.jsx)(n.li,{children:"Consider converting private methods to non-exported functions within the same file but outside of any class, and moving private properties into a separate, non-exported class."}),"\n",(0,i.jsxs)(n.li,{children:["TypeScript symbols are public by default. Never use the ",(0,i.jsx)(n.code,{children:"public"})," modifier except when declaring non-readonly public parameter properties (in constructors)."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nclass Foo {\n  public bar = new Bar(); // BAD: public modifier not needed\n  constructor(public readonly baz: Baz) {} // BAD: readonly implies it's a property which defaults to public\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nclass Foo {\n  bar = new Bar(); // GOOD: public modifier not needed\n  constructor(public baz: Baz) {} // public modifier allowed\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See also ",(0,i.jsx)(n.a,{href:"#export-visibility",children:"export visibility"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"disallowed-class-patterns",children:"Disallowed class patterns"}),"\n",(0,i.jsx)(n.h4,{id:"do-not-manipulate-prototypes-directly",children:"Do not manipulate prototypes directly"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"class"})," keyword allows clearer and more readable class definitions than defining ",(0,i.jsx)(n.code,{children:"prototype"})," properties. Ordinary implementation code has no business manipulating these objects. Mixins and modifying the prototypes of builtin objects are explicitly forbidden."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Exception:"})," Framework code (such as Polymer, or Angular) may need to use ",(0,i.jsx)(n.code,{children:"prototype"}),"s, and should not resort to even-worse workarounds to avoid doing so."]}),"\n",(0,i.jsx)(n.h2,{id:"interfaces",children:"Interfaces"}),"\n",(0,i.jsx)(n.h3,{id:"primitive-literals",children:"Primitive literals"}),"\n",(0,i.jsx)(n.h4,{id:"string-literals",children:"String literals"}),"\n",(0,i.jsx)(n.h5,{id:"use-single-quotes",children:"Use single quotes"}),"\n",(0,i.jsxs)(n.p,{children:["Ordinary string literals are delimited with single quotes (",(0,i.jsx)(n.code,{children:"'"}),"), rather than double quotes (",(0,i.jsx)(n.code,{children:'"'}),")."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tip:"})," if a string contains a single quote character, consider using a template string to avoid having to escape the quote."]}),"\n",(0,i.jsx)(n.h5,{id:"no-line-continuations",children:"No line continuations"}),"\n",(0,i.jsx)(n.p,{children:"Do not use line continuations (that is, ending a line inside a string literal with a backslash) in either ordinary or template string literals. Even though ES5 allows this, it can lead to tricky errors if any trailing whitespace comes after the slash, and is less obvious to readers."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Disallowed:\nconst LONG_STRING = 'This is a very very very very very very very long string. \\\n    It inadvertently contains long stretches of spaces due to how the \\\n    continued lines are indented.';\n"})}),"\n",(0,i.jsx)(n.p,{children:"Instead, write:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nconst LONG_STRING = 'This is a very very very very very very long string. ' +\n    'It does not contain long stretches of spaces because it uses ' +\n    'concatenated strings.';\n\nconst SINGLE_STRING =\n    'http://it.is.also/acceptable_to_use_a_single_long_string_when_breaking_would_hinder_search_discoverability';\n"})}),"\n",(0,i.jsx)(n.h5,{id:"template-literals",children:"Template literals"}),"\n",(0,i.jsxs)(n.p,{children:["Use template literals (delimited with ",(0,i.jsx)(n.code,{children:"`"}),") over complex string concatenation, particularly if multiple string literals are involved. Template literals may span multiple lines."]}),"\n",(0,i.jsx)(n.p,{children:"If a template literal spans multiple lines, it does not need to follow the indentation of the enclosing block, though it may if the added whitespace does not matter."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function arithmetic(a: number, b: number) {\n  return `Here is a table of arithmetic operations:\n${a} + ${b} = ${a + b}\n${a} - ${b} = ${a - b}\n${a} * ${b} = ${a * b}\n${a} / ${b} = ${a / b}`;\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"number-literals",children:"Number literals"}),"\n",(0,i.jsxs)(n.p,{children:["Numbers may be specified in decimal, hex, octal, or binary. Use exactly ",(0,i.jsx)(n.code,{children:"0x"}),", ",(0,i.jsx)(n.code,{children:"0o"}),", and ",(0,i.jsx)(n.code,{children:"0b"})," prefixes, with lowercase letters, for hex, octal, and binary, respectively. Never include a leading zero unless it is immediately followed by ",(0,i.jsx)(n.code,{children:"x"}),", ",(0,i.jsx)(n.code,{children:"o"}),", or ",(0,i.jsx)(n.code,{children:"b"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"type-coercion",children:"Type coercion"}),"\n",(0,i.jsxs)(n.p,{children:["TypeScript code may use the ",(0,i.jsx)(n.code,{children:"String()"})," and ",(0,i.jsx)(n.code,{children:"Boolean()"})," (note: no ",(0,i.jsx)(n.code,{children:"new"}),"!) functions, string template literals, or ",(0,i.jsx)(n.code,{children:"!!"})," to coerce types."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const bool = Boolean(false);\nconst str = String(aNumber);\nconst bool2 = !!str;\nconst str2 = `result: ${bool2}`;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Values of enum types (including unions of enum types and other types) must not be converted to booleans with ",(0,i.jsx)(n.code,{children:"Boolean()"})," or ",(0,i.jsx)(n.code,{children:"!!"}),", and must instead be compared explicitly with comparison operators."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nenum SupportLevel {\n  NONE,\n  BASIC,\n  ADVANCED,\n}\n\nconst level: SupportLevel = ...;\nlet enabled = Boolean(level);\n\nconst maybeLevel: SupportLevel|undefined = ...;\nenabled = !!maybeLevel;\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nenum SupportLevel {\n  NONE,\n  BASIC,\n  ADVANCED,\n}\n\nconst level: SupportLevel = ...;\nlet enabled = level !== SupportLevel.NONE;\n\nconst maybeLevel: SupportLevel|undefined = ...;\nenabled = level !== undefined && level !== SupportLevel.NONE;\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why?"})}),"\n",(0,i.jsx)(n.p,{children:"For most purposes, it doesn't matter what number or string value an enum name is mapped to at runtime, because values of enum types are referred to by name in source code. Consequently, engineers are accustomed to not thinking about this, and so situations where it does matter are undesirable because they will be surprising. Such is the case with conversion of enums to booleans; in particular, by default, the first declared enum value is falsy (because it is 0) while the others are truthy, which is likely to be unexpected. Readers of code that uses an enum value may not even know whether it's the first declared value or not."}),"\n",(0,i.jsx)(n.p,{children:"Using string concatenation to cast to string is discouraged, as we check that operands to the plus operator are of matching types."}),"\n",(0,i.jsxs)(n.p,{children:["Code must use ",(0,i.jsx)(n.code,{children:"Number()"})," to parse numeric values, and must check its return for ",(0,i.jsx)(n.code,{children:"NaN"})," values explicitly, unless failing to parse is impossible from context."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," ",(0,i.jsx)(n.code,{children:"Number('')"}),", ",(0,i.jsx)(n.code,{children:"Number(' ')"}),", and ",(0,i.jsx)(n.code,{children:"Number('\\t')"})," would return ",(0,i.jsx)(n.code,{children:"0"})," instead of ",(0,i.jsx)(n.code,{children:"NaN"}),". ",(0,i.jsx)(n.code,{children:"Number('Infinity')"})," and ",(0,i.jsx)(n.code,{children:"Number('-Infinity')"})," would return ",(0,i.jsx)(n.code,{children:"Infinity"})," and ",(0,i.jsx)(n.code,{children:"-Infinity"})," respectively. Additionally, exponential notation such as ",(0,i.jsx)(n.code,{children:"Number('1e+309')"})," and ",(0,i.jsx)(n.code,{children:"Number('-1e+309')"})," can overflow into ",(0,i.jsx)(n.code,{children:"Infinity"}),". These cases may require special handling."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const aNumber = Number('123');\nif (!isFinite(aNumber)) throw new Error(...);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Code must not use unary plus (",(0,i.jsx)(n.code,{children:"+"}),") to coerce strings to numbers. Parsing numbers can fail, has surprising corner cases, and can be a code smell (parsing at the wrong layer). A unary plus is too easy to miss in code reviews given this."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nconst x = +y;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Code also must not use ",(0,i.jsx)(n.code,{children:"parseInt"})," or ",(0,i.jsx)(n.code,{children:"parseFloat"})," to parse numbers, except for non-base-10 strings (see below). Both of those functions ignore trailing characters in the string, which can shadow error conditions (e.g. parsing ",(0,i.jsx)(n.code,{children:"12 dwarves"})," as ",(0,i.jsx)(n.code,{children:"12"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad - Error prone, regardless of passing a radix.\nconst n = parseInt(someString, 10);\nconst f = parseFloat(someString);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Code that requires parsing with a radix must check that its input contains only appropriate digits for that radix before calling into ",(0,i.jsx)(n.code,{children:"parseInt"}),";"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);\n// Needed to parse hexadecimal.\n// tslint:disable-next-line:ban\nconst n = parseInt(someString, 16); // Only allowed for radix != 10\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"Number()"})," followed by ",(0,i.jsx)(n.code,{children:"Math.floor"})," or ",(0,i.jsx)(n.code,{children:"Math.trunc"})," (where available) to parse integer numbers:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"let f = Number(someString);\nif (isNaN(f)) handleError();\nf = Math.floor(f);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"implicit-coercion",children:"Implicit coercion"}),"\n",(0,i.jsxs)(n.p,{children:["Do not use explicit boolean coercions in conditional clauses that have implicit boolean coercion. Those are the conditions in an ",(0,i.jsx)(n.code,{children:"if"}),", ",(0,i.jsx)(n.code,{children:"for"})," and ",(0,i.jsx)(n.code,{children:"while"})," statements."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nconst foo: MyInterface|null = ...;\nif (!!foo) {...}\nwhile (!!foo) {...}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nconst foo: MyInterface|null = ...;\nif (foo) {...}\nwhile (foo) {...}\n"})}),"\n",(0,i.jsx)(n.p,{children:"As with explicit conversions, values of enum types (including unions of enum types and other types) must not be implicitly coerced to booleans, and must instead be compared explicitly with comparison operators."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nenum SupportLevel {\n  NONE,\n  BASIC,\n  ADVANCED,\n}\n\nconst level: SupportLevel = ...;\nif (level) {...}\n\nconst maybeLevel: SupportLevel|undefined = ...;\nif (level) {...}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nenum SupportLevel {\n  NONE,\n  BASIC,\n  ADVANCED,\n}\n\nconst level: SupportLevel = ...;\nif (level !== SupportLevel.NONE) {...}\n\nconst maybeLevel: SupportLevel|undefined = ...;\nif (level !== undefined && level !== SupportLevel.NONE) {...}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Other types of values may be either implicitly coerced to booleans or compared explicitly with comparison operators:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Explicitly comparing > 0 is OK:\nif (arr.length > 0) {...}\n// so is relying on boolean coercion:\nif (arr.length) {...}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(n.h3,{id:"terminology",children:"Terminology"}),"\n",(0,i.jsxs)(n.p,{children:["There are many different types of functions, with subtle distinctions between them. This guide uses the following terminology, which aligns with ",(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions",children:"MDN"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"function declaration"}),": a declaration (i.e. not an expression) using the ",(0,i.jsx)(n.code,{children:"function"})," keyword"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"function expression"}),": an expression, typically used in an assignment or passed as a parameter, using the ",(0,i.jsx)(n.code,{children:"function"})," keyword"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"arrow function"}),": an expression using the ",(0,i.jsx)(n.code,{children:"=>"})," syntax"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"block body"}),": right hand side of an arrow function with braces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"concise body"}),": right hand side of an arrow function without braces"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Methods and classes/constructors are not covered in this section."}),"\n",(0,i.jsx)(n.h3,{id:"prefer-function-declarations-for-named-functions",children:"Prefer function declarations for named functions"}),"\n",(0,i.jsx)(n.p,{children:"Prefer function declarations over arrow functions or function expressions when defining named functions."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nfunction foo() {\n  return 42;\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nconst foo = () => 42;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Arrow functions may be used, for example, when an explicit type annotation is required."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface SearchFunction {\n  (source: string, subString: string): boolean;\n}\n\nconst fooSearch: SearchFunction = (source, subString) => { ... };\n"})}),"\n",(0,i.jsx)(n.h3,{id:"nested-functions",children:"Nested functions"}),"\n",(0,i.jsxs)(n.p,{children:["Functions nested within other methods or functions may use function declarations or arrow functions, as appropriate. In method bodies in particular, arrow functions are preferred because they have access to the outer ",(0,i.jsx)(n.code,{children:"this"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"do-not-use-function-expressions",children:"Do not use function expressions"}),"\n",(0,i.jsx)(n.p,{children:"Do not use function expressions. Use arrow functions instead."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nbar(() => { this.doSomething(); })\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nbar(function() { ... })\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Exception:"})," Function expressions may be used only if code has to dynamically rebind ",(0,i.jsx)(n.code,{children:"this"})," (but this is discouraged), or for generator functions (which do not have an arrow syntax)."]}),"\n",(0,i.jsx)(n.h3,{id:"arrow-function-bodies",children:"Arrow function bodies"}),"\n",(0,i.jsx)(n.p,{children:"Use arrow functions with concise bodies (i.e. expressions) or block bodies as appropriate."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Top level functions use function declarations.\nfunction someFunction() {\n  // Block bodies are fine:\n  const receipts = books.map((b: Book) => {\n    const receipt = payMoney(b.price);\n    recordTransaction(receipt);\n    return receipt;\n  });\n\n  // Concise bodies are fine, too, if the return value is used:\n  const longThings = myValues.filter(v => v.length > 1000).map(v => String(v));\n\n  function payMoney(amount: number) {\n    // function declarations are fine, but must not access `this`.\n  }\n\n  // Nested arrow functions may be assigned to a const.\n  const computeTax = (amount: number) => amount * 0.12;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Only use a concise body if the return value of the function is actually used. The block body makes sure the return type is ",(0,i.jsx)(n.code,{children:"void"})," then and prevents potential side effects."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c BAD: use a block body if the return value of the function is not used.\nmyPromise.then(v => console.log(v));\n\n// \u274c BAD: this typechecks, but the return value still leaks.\nlet f: () => void;\nf = () => 1;\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 GOOD: return value is unused, use a block body.\nmyPromise.then(v => {\n  console.log(v);\n});\n\n// \u2705 GOOD: code may use blocks for readability.\nconst transformed = [1, 2, 3].map(v => {\n  const intermediate = someComplicatedExpr(v);\n  const more = acrossManyLines(intermediate);\n  return worthWrapping(more);\n});\n\n// \u2705 GOOD: explicit `void` ensures no leaked return value\nmyPromise.then(v => void console.log(v));\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tip:"})," The ",(0,i.jsx)(n.code,{children:"void"})," operator can be used to ensure an arrow function with an expression body returns ",(0,i.jsx)(n.code,{children:"undefined"})," when the result is unused."]}),"\n",(0,i.jsx)(n.h3,{id:"rebinding-this",children:"Rebinding this"}),"\n",(0,i.jsxs)(n.p,{children:["Function expressions and function declarations must not use ",(0,i.jsx)(n.code,{children:"this"})," unless they specifically exist to rebind the ",(0,i.jsx)(n.code,{children:"this"})," pointer. Rebinding ",(0,i.jsx)(n.code,{children:"this"})," can in most cases be avoided by using arrow functions or explicit parameters."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nfunction clickHandler() {\n  // Bad: what's `this` in this context?\n  this.textContent = 'Hello';\n}\n\n// Bad: the `this` pointer reference is implicitly set to document.body.\ndocument.body.onclick = clickHandler;\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\n// Good: explicitly reference the object from an arrow function.\ndocument.body.onclick = () => { document.body.textContent = 'hello'; };\n\n// Alternatively: take an explicit parameter\nconst setTextFn = (e: HTMLElement) => { e.textContent = 'hello'; };\ndocument.body.onclick = setTextFn.bind(null, document.body);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Prefer arrow functions over other approaches to binding ",(0,i.jsx)(n.code,{children:"this"}),", such as ",(0,i.jsx)(n.code,{children:"f.bind(this)"}),", ",(0,i.jsx)(n.code,{children:"goog.bind(f, this)"}),", or ",(0,i.jsx)(n.code,{children:"const self = this"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"prefer-passing-arrow-functions-as-callbacks",children:"Prefer passing arrow functions as callbacks"}),"\n",(0,i.jsx)(n.p,{children:"Callbacks can be invoked with unexpected arguments that can pass a type check but still result in logical errors."}),"\n",(0,i.jsx)(n.p,{children:"Avoid passing a named callback to a higher-order function, unless you are sure of the stability of both functions' call signatures. Beware, in particular, of less-commonly-used optional parameters."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c BAD: Arguments are not explicitly passed, leading to unintended behavior\n// when the optional `radix` argument gets the array indices 0, 1, and 2.\nconst numbers = ['11', '5', '10'].map(parseInt);\n// > [11, NaN, 2];\n"})}),"\n",(0,i.jsx)(n.p,{children:"Instead, prefer passing an arrow-function that explicitly forwards parameters to the named callback."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 GOOD: Arguments are explicitly passed to the callback\nconst numbers = ['11', '5', '3'].map((n) => parseInt(n));\n// > [11, 5, 3]\n\n// \u2705 GOOD: Function is locally defined and is designed to be used as a callback\nfunction dayFilter(element: string|null|undefined) {\n  return element != null && element.endsWith('day');\n}\nconst days = ['tuesday', undefined, 'juice', 'wednesday'].filter(dayFilter);\n"})}),"\n",(0,i.jsx)(n.h3,{id:"arrow-functions-as-properties",children:"Arrow functions as properties"}),"\n",(0,i.jsxs)(n.p,{children:["Classes usually should not contain properties initialized to arrow functions. Arrow function properties require the calling function to understand that the callee's ",(0,i.jsx)(n.code,{children:"this"})," is already bound, which increases confusion about what ",(0,i.jsx)(n.code,{children:"this"})," is, and call sites and references using such handlers look broken (i.e. require non-local knowledge to determine that they are correct). Code should always use arrow functions to call instance methods (",(0,i.jsx)(n.code,{children:"const handler = (x) => { this.listener(x); };"}),"), and should not obtain or pass references to instance methods (",(0,i.jsx)(n.code,{children:"const handler = this.listener; handler(x);"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," in some specific situations, e.g. when binding functions in a template, arrow functions as properties are useful and create much more readable code. Use judgement with this rule. Also, see the section below on Event Handlers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Problem\nclass DelayHandler {\n  constructor() {\n    // Problem: `this` is not preserved in the callback. `this` in the callback\n    // will not be an instance of DelayHandler.\n    setTimeout(this.patienceTracker, 5000);\n  }\n  private patienceTracker() {\n    this.waitedPatiently = true;\n  }\n}\n\n// \u274c Arrow functions usually should not be properties.\nclass DelayHandler {\n  constructor() {\n    // Bad: this code looks like it forgot to bind `this`.\n    setTimeout(this.patienceTracker, 5000);\n  }\n  private patienceTracker = () => {\n    this.waitedPatiently = true;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Explicitly manage `this` at call time.\nclass DelayHandler {\n  constructor() {\n    // Use anonymous functions if possible.\n    setTimeout(() => {\n      this.patienceTracker();\n    }, 5000);\n  }\n  private patienceTracker() {\n    this.waitedPatiently = true;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"event-handlers",children:"Event handlers"}),"\n",(0,i.jsxs)(n.p,{children:["Event handlers may use arrow functions when there is no need to uninstall the handler (for example, if the event is emitted by the class itself). If the handler requires uninstallation, arrow function properties are the right approach, because they automatically capture ",(0,i.jsx)(n.code,{children:"this"})," and provide a stable reference to uninstall."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// Event handlers may be anonymous functions or arrow function properties.\nclass Component {\n  onAttached() {\n    // The event is emitted by this class, no need to uninstall.\n    this.addEventListener('click', () => {\n      this.listener();\n    });\n    // this.listener is a stable reference, we can uninstall it later.\n    window.addEventListener('onbeforeunload', this.listener);\n  }\n\n  onDetached() {\n    // The event is emitted by window. If we don't uninstall, this.listener will\n    // keep a reference to `this` because it's bound, causing a memory leak.\n    window.removeEventListener('onbeforeunload', this.listener);\n  }\n\n  // An arrow function stored in a property is bound to `this` automatically.\n  private listener = () => {\n    confirm('Do you want to exit the page?');\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Do not use ",(0,i.jsx)(n.code,{children:"bind"})," in the expression that installs an event handler, because it creates a temporary reference that can't be uninstalled."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Binding listeners creates a temporary reference that prevents uninstalling.\nclass Component {\n  onAttached() {\n    // This creates a temporary reference that we won't be able to uninstall\n    window.addEventListener('onbeforeunload', this.listener.bind(this));\n  }\n  onDetached() {\n    // This bind creates a different reference, so this line does nothing.\n    window.removeEventListener('onbeforeunload', this.listener.bind(this));\n  }\n  private listener() {\n    confirm('Do you want to exit the page?');\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"parameter-initializers",children:"Parameter initializers"}),"\n",(0,i.jsx)(n.p,{children:"Optional function parameters may be given a default initializer to use when the argument is omitted. Initializers must not have any observable side effects. Initializers should be kept as simple as possible."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good\nfunction process(name: string, extraContext: string[] = []) {}\nfunction activate(index = 0) {}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c BAD: side effect of incrementing the counter\nlet globalCounter = 0;\nfunction newId(index = globalCounter++) {}\n\n// \u274c BAD: exposes shared mutable state, which can introduce unintended coupling\n// between function calls\nclass Foo {\n  private readonly defaultPaths: string[];\n  frobnicate(paths = defaultPaths) {}\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Use default parameters sparingly. Prefer destructuring to create readable APIs when there are more than a small handful of optional parameters that do not have a natural order."}),"\n",(0,i.jsx)(n.h3,{id:"prefer-rest-and-spread-when-appropriate",children:"Prefer rest and spread when appropriate"}),"\n",(0,i.jsxs)(n.p,{children:["Use a rest parameter instead of accessing ",(0,i.jsx)(n.code,{children:"arguments"}),". Never name a local variable or parameter ",(0,i.jsx)(n.code,{children:"arguments"}),", which confusingly shadows the built-in name."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function variadic(array: string[], ...numbers: number[]) {}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Use function spread syntax instead of ",(0,i.jsx)(n.code,{children:"Function.prototype.apply"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"formatting-functions",children:"Formatting functions"}),"\n",(0,i.jsx)(n.p,{children:"Blank lines at the start or end of the function body are not allowed."}),"\n",(0,i.jsx)(n.p,{children:"A single blank line may be used within function bodies sparingly to create logical groupings of statements."}),"\n",(0,i.jsxs)(n.p,{children:["Generators should attach the ",(0,i.jsx)(n.code,{children:"*"})," to the ",(0,i.jsx)(n.code,{children:"function"})," and ",(0,i.jsx)(n.code,{children:"yield"})," keywords, as in ",(0,i.jsx)(n.code,{children:"function* foo()"})," and ",(0,i.jsx)(n.code,{children:"yield* iter"}),", rather than ",(0,i.jsx)(n.code,{children:"function *foo()"})," or ",(0,i.jsx)(n.code,{children:"yield *iter"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Parentheses around the left-hand side of a single-argument arrow function are recommended but not required."}),"\n",(0,i.jsxs)(n.p,{children:["Do not put a space after the ",(0,i.jsx)(n.code,{children:"..."})," in rest or spread syntax."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"function myFunction(...elements: number[]) {}\nmyFunction(...array, ...iterable, ...generator());\n"})}),"\n",(0,i.jsx)(n.h3,{id:"this",children:"this"}),"\n",(0,i.jsxs)(n.p,{children:["Only use ",(0,i.jsx)(n.code,{children:"this"})," in class constructors and methods, functions that have an explicit ",(0,i.jsx)(n.code,{children:"this"})," type declared (e.g. ",(0,i.jsx)(n.code,{children:"function func(this: ThisType, ...)"}),"), or in arrow functions defined in a scope where ",(0,i.jsx)(n.code,{children:"this"})," may be used."]}),"\n",(0,i.jsxs)(n.p,{children:["Never use ",(0,i.jsx)(n.code,{children:"this"})," to refer to the global object, the context of an ",(0,i.jsx)(n.code,{children:"eval"}),", the target of an event, or unnecessarily ",(0,i.jsx)(n.code,{children:"call()"}),"ed or ",(0,i.jsx)(n.code,{children:"apply()"}),"ed functions."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Bad\nthis.alert('Hello');\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(6540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);