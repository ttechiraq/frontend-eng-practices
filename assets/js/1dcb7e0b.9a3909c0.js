"use strict";(self.webpackChunkfrontend_eng_practices=self.webpackChunkfrontend_eng_practices||[]).push([[77],{4170:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"typescript/toolchain-requirements","title":"Toolchain requirements","description":"Google style requires using a number of tools in specific ways, outlined here.","source":"@site/docs/1-typescript/7-toolchain-requirements.md","sourceDirName":"1-typescript","slug":"/typescript/toolchain-requirements","permalink":"/frontend-eng-practices/typescript/toolchain-requirements","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/1-typescript/7-toolchain-requirements.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Type system","permalink":"/frontend-eng-practices/typescript/type-system"},"next":{"title":"Comments and documentation","permalink":"/frontend-eng-practices/typescript/comments-and-documentation"}}');var t=r(4848),o=r(8453);const i={sidebar_position:7},c="Toolchain requirements",a={},l=[{value:"TypeScript compiler",id:"typescript-compiler",level:2},{value:"@ts-ignore",id:"ts-ignore",level:2},{value:"Conformance",id:"conformance",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"toolchain-requirements",children:"Toolchain requirements"})}),"\n",(0,t.jsx)(n.p,{children:"Google style requires using a number of tools in specific ways, outlined here."}),"\n",(0,t.jsx)(n.h2,{id:"typescript-compiler",children:"TypeScript compiler"}),"\n",(0,t.jsx)(n.p,{children:"All TypeScript files must pass type checking using the standard tool chain."}),"\n",(0,t.jsx)(n.h2,{id:"ts-ignore",children:"@ts-ignore"}),"\n",(0,t.jsxs)(n.p,{children:["Do not use ",(0,t.jsx)(n.code,{children:"@ts-ignore"})," nor the variants ",(0,t.jsx)(n.code,{children:"@ts-expect-error"})," or ",(0,t.jsx)(n.code,{children:"@ts-nocheck"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why?"})}),"\n",(0,t.jsx)(n.p,{children:"They superficially seem to be an easy way to fix a compiler error, but in practice, a specific compiler error is often caused by a larger problem that can be fixed more directly."}),"\n",(0,t.jsxs)(n.p,{children:["For example, if you are using ",(0,t.jsx)(n.code,{children:"@ts-ignore"})," to suppress a type error, then it's hard to predict what types the surrounding code will end up seeing. For many type errors, the advice in ",(0,t.jsx)(n.a,{href:"#any",children:"how to best use any"})," is useful."]}),"\n",(0,t.jsxs)(n.p,{children:["You may use ",(0,t.jsx)(n.code,{children:"@ts-expect-error"})," in unit tests, though you generally should not. ",(0,t.jsx)(n.code,{children:"@ts-expect-error"})," suppresses all errors. It's easy to accidentally over-match and suppress more serious errors. Consider one of:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When testing APIs that need to deal with unchecked values at runtime, add casts to the expected type or to ",(0,t.jsx)(n.code,{children:"any"})," and add an explanatory comment. This limits error suppression to a single expression."]}),"\n",(0,t.jsxs)(n.li,{children:["Suppress the lint warning and document why, similar to ",(0,t.jsxs)(n.a,{href:"#any-suppress",children:["suppressing ",(0,t.jsx)(n.code,{children:"any"})," lint warnings"]}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conformance",children:"Conformance"}),"\n",(0,t.jsxs)(n.p,{children:["Google TypeScript includes several conformance frameworks, ",(0,t.jsx)(n.a,{href:"https://tsetse.info",children:"tsetse"})," and ",(0,t.jsx)(n.a,{href:"https://github.com/google/tsec",children:"tsec"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["These rules are commonly used to enforce critical restrictions (such as defining globals, which could break the codebase) and security patterns (such as using ",(0,t.jsx)(n.code,{children:"eval"})," or assigning to ",(0,t.jsx)(n.code,{children:"innerHTML"}),"), or more loosely to improve code quality."]}),"\n",(0,t.jsx)(n.p,{children:"Google-style TypeScript must abide by any applicable global or framework-local conformance rules."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>c});var s=r(6540);const t={},o=s.createContext(t);function i(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);