"use strict";(self.webpackChunkfrontend_eng_practices=self.webpackChunkfrontend_eng_practices||[]).push([[293],{3700:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"typescript/type-system","title":"Type system","description":"Type inference","source":"@site/docs/1-typescript/6-type-system.md","sourceDirName":"1-typescript","slug":"/typescript/type-system","permalink":"/frontend-eng-practices/typescript/type-system","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/1-typescript/6-type-system.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Naming","permalink":"/frontend-eng-practices/typescript/naming"},"next":{"title":"Toolchain requirements","permalink":"/frontend-eng-practices/typescript/toolchain-requirements"}}');var r=s(4848),i=s(8453);const a={},o="Type system",l={},c=[{value:"Type inference",id:"type-inference",level:2},{value:"Return types",id:"return-types",level:2},{value:"Undefined and null",id:"undefined-and-null",level:2},{value:"Nullable/undefined type aliases",id:"nullableundefined-type-aliases",level:2},{value:"Prefer optional over |undefined",id:"prefer-optional-over-undefined",level:2},{value:"Use structural types",id:"use-structural-types",level:2},{value:"Use interfaces to define structural types, not classes",id:"use-interfaces-to-define-structural-types-not-classes",level:2},{value:"Why?",id:"why",level:3},{value:"Prefer interfaces over type literal aliases",id:"prefer-interfaces-over-type-literal-aliases",level:2},{value:"Why?",id:"why-1",level:3},{value:"<code>Array&lt;T&gt;</code> Type",id:"arrayt-type",level:2},{value:"Indexable types / index signatures (<code>{[key: string]: T}</code>)",id:"indexable-types--index-signatures-key-string-t",level:2},{value:"Mapped and conditional types",id:"mapped-and-conditional-types",level:2},{value:"<code>any</code> Type",id:"any-type",level:2},{value:"Providing a more specific type",id:"providing-a-more-specific-type",level:3},{value:"Using <code>unknown</code> over <code>any</code>",id:"using-unknown-over-any",level:3},{value:"Suppressing <code>any</code> lint warnings",id:"suppressing-any-lint-warnings",level:3},{value:"<code>{}</code> Type",id:"-type",level:2},{value:"Tuple types",id:"tuple-types",level:2},{value:"Wrapper types",id:"wrapper-types",level:2},{value:"Return type only generics",id:"return-type-only-generics",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"type-system",children:"Type system"})}),"\n",(0,r.jsx)(n.h2,{id:"type-inference",children:"Type inference"}),"\n",(0,r.jsx)(n.p,{children:"Code may rely on type inference as implemented by the TypeScript compiler for all type expressions (variables, fields, return types, etc)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const x = 15; // Type inferred.\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Leave out type annotations for trivially inferred types: variables or parameters initialized to a ",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"number"}),", ",(0,r.jsx)(n.code,{children:"boolean"}),", ",(0,r.jsx)(n.code,{children:"RegExp"})," literal or ",(0,r.jsx)(n.code,{children:"new"})," expression."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const x: boolean = true; // Bad: 'boolean' here does not aid readability\n// Bad: 'Set' is trivially inferred from the initialization\nconst x: Set<string> = new Set();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Explicitly specifying types may be required to prevent generic type parameters from being inferred as ",(0,r.jsx)(n.code,{children:"unknown"}),". For example, initializing generic types with no values (e.g. empty arrays, objects, ",(0,r.jsx)(n.code,{children:"Map"}),"s, or ",(0,r.jsx)(n.code,{children:"Set"}),"s)."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const x = new Set<string>();\n"})}),"\n",(0,r.jsx)(n.p,{children:"For more complex expressions, type annotations can help with readability of the program:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Hard to reason about the type of 'value' without an annotation.\nconst value = await rpc.getSomeValue().transform();\n// Can tell the type of 'value' at a glance.\nconst value: string[] = await rpc.getSomeValue().transform();\n"})}),"\n",(0,r.jsx)(n.p,{children:"Whether an annotation is required is decided by the code reviewer."}),"\n",(0,r.jsx)(n.h2,{id:"return-types",children:"Return types"}),"\n",(0,r.jsx)(n.p,{children:"Whether to include return type annotations for functions and methods is up to the code author. Reviewers may ask for annotations to clarify complex return types that are hard to understand. Projects may have a local policy to always require return types, but this is not a general TypeScript style requirement."}),"\n",(0,r.jsx)(n.p,{children:"There are two benefits to explicitly typing out the implicit return values of functions and methods:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"More precise documentation to benefit readers of the code."}),"\n",(0,r.jsx)(n.li,{children:"Surface potential type errors faster in the future if there are code changes that change the return type of the function."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"undefined-and-null",children:"Undefined and null"}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript supports ",(0,r.jsx)(n.code,{children:"undefined"})," and ",(0,r.jsx)(n.code,{children:"null"})," types. Nullable types can be constructed as a union type (",(0,r.jsx)(n.code,{children:"string|null"}),"); similarly with ",(0,r.jsx)(n.code,{children:"undefined"}),". There is no special syntax for unions of ",(0,r.jsx)(n.code,{children:"undefined"})," and ",(0,r.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript code can use either ",(0,r.jsx)(n.code,{children:"undefined"})," or ",(0,r.jsx)(n.code,{children:"null"})," to denote absence of a value, there is no general guidance to prefer one over the other. Many JavaScript APIs use ",(0,r.jsx)(n.code,{children:"undefined"})," (e.g. ",(0,r.jsx)(n.code,{children:"Map.get"}),"), while many DOM and Google APIs use ",(0,r.jsx)(n.code,{children:"null"})," (e.g. ",(0,r.jsx)(n.code,{children:"Element.getAttribute"}),"), so the appropriate absent value depends on the context."]}),"\n",(0,r.jsx)(n.h2,{id:"nullableundefined-type-aliases",children:"Nullable/undefined type aliases"}),"\n",(0,r.jsxs)(n.p,{children:["Type aliases must not include ",(0,r.jsx)(n.code,{children:"|null"})," or ",(0,r.jsx)(n.code,{children:"|undefined"})," in a union type."]}),"\n",(0,r.jsxs)(n.p,{children:["Nullable aliases typically indicate that null values are being passed around through too many layers of an application, and this clouds the source of the original issue that resulted in ",(0,r.jsx)(n.code,{children:"null"}),". They also make it unclear when specific values on a class or interface might be absent."]}),"\n",(0,r.jsxs)(n.p,{children:["Instead, code must only add ",(0,r.jsx)(n.code,{children:"|null"})," or ",(0,r.jsx)(n.code,{children:"|undefined"})," when the alias is actually used. Code should deal with null values close to where they arise, using the above techniques."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Bad\ntype CoffeeResponse = Latte|Americano|undefined;\n\nclass CoffeeService {\n  getLatte(): CoffeeResponse { ... };\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Better\ntype CoffeeResponse = Latte|Americano;\n\nclass CoffeeService {\n  getLatte(): CoffeeResponse|undefined { ... };\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"prefer-optional-over-undefined",children:"Prefer optional over |undefined"}),"\n",(0,r.jsxs)(n.p,{children:["In addition, TypeScript supports a special construct for optional parameters and fields, using ",(0,r.jsx)(n.code,{children:"?"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface CoffeeOrder {\n  sugarCubes: number;\n  milk?: Whole|LowFat|HalfHalf;\n}\n\nfunction pourCoffee(volume?: Milliliter) { ... }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Optional parameters implicitly include ",(0,r.jsx)(n.code,{children:"|undefined"})," in their type. However, they are different in that they can be left out when constructing a value or calling a method. For example, ",(0,r.jsx)(n.code,{children:"{sugarCubes: 1}"})," is a valid ",(0,r.jsx)(n.code,{children:"CoffeeOrder"})," because ",(0,r.jsx)(n.code,{children:"milk"})," is optional."]}),"\n",(0,r.jsxs)(n.p,{children:["Use optional fields (on interfaces or classes) and parameters rather than a ",(0,r.jsx)(n.code,{children:"|undefined"})," type."]}),"\n",(0,r.jsx)(n.p,{children:"For classes preferably avoid this pattern altogether and initialize as many fields as possible."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class MyClass {\n  field = '';\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"use-structural-types",children:"Use structural types"}),"\n",(0,r.jsx)(n.p,{children:"TypeScript's type system is structural, not nominal. That is, a value matches a type if it has at least all the properties the type requires and the properties' types match, recursively."}),"\n",(0,r.jsx)(n.p,{children:"When providing a structural-based implementation, explicitly include the type at the declaration of the symbol (this allows more precise type checking and error reporting)."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const foo: Foo = {\n  a: 123,\n  b: 'abc',\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const badFoo = {\n  a: 123,\n  b: 'abc',\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"use-interfaces-to-define-structural-types-not-classes",children:"Use interfaces to define structural types, not classes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Foo {\n  a: number;\n  b: string;\n}\n\nconst foo: Foo = {\n  a: 123,\n  b: 'abc',\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class Foo {\n  readonly a: number;\n  readonly b: number;\n}\n\nconst foo: Foo = {\n  a: 123,\n  b: 'abc',\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"why",children:"Why?"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"badFoo"})," object above relies on type inference. Additional fields could be added to ",(0,r.jsx)(n.code,{children:"badFoo"})," and the type is inferred based on the object itself."]}),"\n",(0,r.jsxs)(n.p,{children:["When passing a ",(0,r.jsx)(n.code,{children:"badFoo"})," to a function that takes a ",(0,r.jsx)(n.code,{children:"Foo"}),", the error will be at the function call site, rather than at the object declaration site. This is also useful when changing the surface of an interface across broad codebases."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Animal {\n  sound: string;\n  name: string;\n}\n\nfunction makeSound(animal: Animal) {}\n\n/**\n * 'cat' has an inferred type of '{sound: string}'\n */\nconst cat = {\n  sound: 'meow',\n};\n\n/**\n * 'cat' does not meet the type contract required for the function, so the\n * TypeScript compiler errors here, which may be very far from where 'cat' is\n * defined.\n */\nmakeSound(cat);\n\n/**\n * Horse has a structural type and the type error shows here rather than the\n * function call. 'horse' does not meet the type contract of 'Animal'.\n */\nconst horse: Animal = {\n  sound: 'niegh',\n};\n\nconst dog: Animal = {\n  sound: 'bark',\n  name: 'MrPickles',\n};\n\nmakeSound(dog);\nmakeSound(horse);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"prefer-interfaces-over-type-literal-aliases",children:"Prefer interfaces over type literal aliases"}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript supports ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases",children:"type aliases"})," for naming a type expression. This can be used to name primitives, unions, tuples, and any other types."]}),"\n",(0,r.jsx)(n.p,{children:"However, when declaring types for objects, use interfaces instead of a type alias for the object literal expression."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface User {\n  firstName: string;\n  lastName: string;\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type User = {\n  firstName: string,\n  lastName: string,\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"why-1",children:"Why?"}),"\n",(0,r.jsxs)(n.p,{children:["These forms are nearly equivalent, so under the principle of just choosing one out of two forms to prevent variation, we should choose one. Additionally, there are also ",(0,r.jsx)(n.a,{href:"https://ncjamieson.com/prefer-interfaces/",children:"interesting technical reasons to prefer interface"}),". That page quotes the TypeScript team lead: Honestly, my take is that it should really just be interfaces for anything that they can model. There is no benefit to type aliases when there are so many issues around display/perf."]}),"\n",(0,r.jsxs)(n.h2,{id:"arrayt-type",children:[(0,r.jsx)(n.code,{children:"Array<T>"})," Type"]}),"\n",(0,r.jsxs)(n.p,{children:["For simple types (containing just alphanumeric characters and dot), use the syntax sugar for arrays, ",(0,r.jsx)(n.code,{children:"T[]"})," or ",(0,r.jsx)(n.code,{children:"readonly T[]"}),", rather than the longer form ",(0,r.jsx)(n.code,{children:"Array<T>"})," or ",(0,r.jsx)(n.code,{children:"ReadonlyArray<T>"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["For multi-dimensional non-",(0,r.jsx)(n.code,{children:"readonly"})," arrays of simple types, use the syntax sugar form (",(0,r.jsx)(n.code,{children:"T[][]"}),", ",(0,r.jsx)(n.code,{children:"T[][][]"}),", and so on) rather than the longer form."]}),"\n",(0,r.jsxs)(n.p,{children:["For anything more complex, use the longer form ",(0,r.jsx)(n.code,{children:"Array<T>"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["These rules apply at each level of nesting, i.e. a simple ",(0,r.jsx)(n.code,{children:"T[]"})," nested in a more complex type would still be spelled as ",(0,r.jsx)(n.code,{children:"T[]"}),", using the syntax sugar."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"let a: string[];\nlet b: readonly string[];\nlet c: ns.MyObj[];\nlet d: string[][];\nlet e: Array<{n: number, s: string}>;\nlet f: Array<string|number>;\nlet g: ReadonlyArray<string|number>;\nlet h: InjectionToken<string[]>; // Use syntax sugar for nested types.\nlet i: ReadonlyArray<string[]>;\nlet j: Array<readonly string[]>;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"let a: Array<string>; // The syntax sugar is shorter.\nlet b: ReadonlyArray<string>;\nlet c: Array<ns.MyObj>;\nlet d: Array<string[]>;\nlet e: {n: number, s: string}[]; // The braces make it harder to read.\nlet f: (string|number)[]; // Likewise with parens.\nlet g: readonly (string | number)[];\nlet h: InjectionToken<Array<string>>;\nlet i: readonly string[][];\nlet j: (readonly string[])[];\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"indexable-types--index-signatures-key-string-t",children:["Indexable types / index signatures (",(0,r.jsx)(n.code,{children:"{[key: string]: T}"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["In JavaScript, it's common to use an object as an associative array (aka ",(0,r.jsx)(n.code,{children:"map"}),", ",(0,r.jsx)(n.code,{children:"hash"}),", or ",(0,r.jsx)(n.code,{children:"dict"}),"). Such objects can be typed using an ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures",children:"index signature"})," (",(0,r.jsx)(n.code,{children:"[k: string]: T"}),") in TypeScript:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const fileSizes: {[fileName: string]: number} = {};\nfileSizes['readme.txt'] = 541;\n"})}),"\n",(0,r.jsx)(n.p,{children:"In TypeScript, provide a meaningful label for the key. (The label only exists for documentation; it's unused otherwise.)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const users: {[key: string]: number} = ...;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const users: {[userName: string]: number} = ...;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Rather than using one of these, consider using the ES6 ",(0,r.jsx)(n.code,{children:"Map"})," and ",(0,r.jsx)(n.code,{children:"Set"})," types instead. JavaScript objects have [surprising undesirable behaviors] and the ES6 types more explicitly convey your intent. Also, ",(0,r.jsx)(n.code,{children:"Map"}),"s can be keyed by\u2014and ",(0,r.jsx)(n.code,{children:"Set"}),"s can contain\u2014types other than ",(0,r.jsx)(n.code,{children:"string"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript's builtin ",(0,r.jsx)(n.code,{children:"Record<Keys, ValueType>"})," type allows constructing types with a defined set of keys. This is distinct from associative arrays in that the keys are statically known. See advice on that ",(0,r.jsx)(n.a,{href:"#mapped-conditional-types",children:"below"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"mapped-and-conditional-types",children:"Mapped and conditional types"}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript's ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/mapped-types.html",children:"mapped types"})," and ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/2/conditional-types.html",children:"conditional types"})," allow specifying new types based on other types. TypeScript's standard library includes several type operators based on these (",(0,r.jsx)(n.code,{children:"Record"}),", ",(0,r.jsx)(n.code,{children:"Partial"}),", ",(0,r.jsx)(n.code,{children:"Readonly"})," etc)."]}),"\n",(0,r.jsx)(n.p,{children:"These type system features allow succinctly specifying types and constructing powerful yet type safe abstractions. They come with a number of drawbacks though:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Compared to explicitly specifying properties and type relations (e.g. using interfaces and extension, see below for an example), type operators require the reader to mentally evaluate the type expression. This can make programs substantially harder to read, in particular combined with type inference and expressions crossing file boundaries."}),"\n",(0,r.jsx)(n.li,{children:"Mapped & conditional types' evaluation model, in particular when combined with type inference, is underspecified, not always well understood, and often subject to change in TypeScript compiler versions. Code can accidentally compile or seem to give the right results. This increases future support cost of code using type operators."}),"\n",(0,r.jsx)(n.li,{children:"Mapped & conditional types are most powerful when deriving types from complex and/or inferred types. On the flip side, this is also when they are most prone to create hard to understand and maintain programs."}),"\n",(0,r.jsxs)(n.li,{children:["Some language tooling does not work well with these type system features. E.g. your IDE's find references (and thus rename property refactoring) will not find properties in a ",(0,r.jsx)(n.code,{children:"Pick<T, Keys>"})," type, and Code Search won't hyperlink them."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The style recommendation is:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Always use the simplest type construct that can possibly express your code."}),"\n",(0,r.jsx)(n.li,{children:"A little bit of repetition or verbosity is often much cheaper than the long term cost of complex type expressions."}),"\n",(0,r.jsx)(n.li,{children:"Mapped & conditional types may be used, subject to these considerations."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For example, TypeScript's builtin ",(0,r.jsx)(n.code,{children:"Pick<T, Keys>"})," type allows creating a new type by subsetting another type ",(0,r.jsx)(n.code,{children:"T"}),", but simple interface extension can often be easier to understand."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface User {\n  shoeSize: number;\n  favoriteIcecream: string;\n  favoriteChocolate: string;\n}\n\n// FoodPreferences has favoriteIcecream and favoriteChocolate, but not shoeSize.\ntype FoodPreferences = Pick<User, 'favoriteIcecream'|'favoriteChocolate'>;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This is equivalent to spelling out the properties on ",(0,r.jsx)(n.code,{children:"FoodPreferences"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface FoodPreferences {\n  favoriteIcecream: string;\n  favoriteChocolate: string;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To reduce duplication, ",(0,r.jsx)(n.code,{children:"User"})," could extend ",(0,r.jsx)(n.code,{children:"FoodPreferences"}),", or (possibly better) nest a field for food preferences:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface FoodPreferences { /* as above */ }\ninterface User extends FoodPreferences {\n  shoeSize: number;\n  // also includes the preferences.\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Using interfaces here makes the grouping of properties explicit, improves IDE support, allows better optimization, and arguably makes the code easier to understand."}),"\n",(0,r.jsxs)(n.h2,{id:"any-type",children:[(0,r.jsx)(n.code,{children:"any"})," Type"]}),"\n",(0,r.jsxs)(n.p,{children:["TypeScript's ",(0,r.jsx)(n.code,{children:"any"})," type is a super and subtype of all other types, and allows dereferencing all properties. As such, ",(0,r.jsx)(n.code,{children:"any"})," is dangerous - it can mask severe programming errors, and its use undermines the value of having static types in the first place."]}),"\n",(0,r.jsxs)(n.p,{children:["Consider not to use ",(0,r.jsx)(n.code,{children:"any"}),". In circumstances where you want to use ",(0,r.jsx)(n.code,{children:"any"}),", consider one of:"]}),"\n",(0,r.jsx)(n.h3,{id:"providing-a-more-specific-type",children:"Providing a more specific type"}),"\n",(0,r.jsx)(n.p,{children:"Use interfaces , an inline object type, or a type alias:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Use declared interfaces to represent server-side JSON.\ndeclare interface MyUserJson {\n  name: string;\n  email: string;\n}\n\n// Use type aliases for types that are repetitive to write.\ntype MyType = number|string;\n\n// Or use inline object types for complex returns.\nfunction getTwoThings(): {something: number, other: string} {\n  // ...\n  return {something, other};\n}\n\n// Use a generic type, where otherwise a library would say `any` to represent\n// they don\'t care what type the user is operating on (but note "Return type\n// only generics" below).\nfunction nicestElement<T>(items: T[]): T {\n  // Find the nicest element in items.\n  // Code can also put constraints on T, e.g. <T extends HTMLElement>.\n}\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"using-unknown-over-any",children:["Using ",(0,r.jsx)(n.code,{children:"unknown"})," over ",(0,r.jsx)(n.code,{children:"any"})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"any"})," type allows assignment into any other type and dereferencing any property off it. Often this behaviour is not necessary or desirable, and code just needs to express that a type is unknown. Use the built-in type ",(0,r.jsx)(n.code,{children:"unknown"})," in that situation \u2014 it expresses the concept and is much safer as it does not allow dereferencing arbitrary properties."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Can assign any value (including null or undefined) into this but cannot\n// use it without narrowing the type or casting.\nconst val: unknown = value;\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const danger: any = value /* result of an arbitrary expression */;\ndanger.whoops(); // This access is completely unchecked!\n"})}),"\n",(0,r.jsxs)(n.p,{children:["To safely use ",(0,r.jsx)(n.code,{children:"unknown"})," values, narrow the type using a ",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types",children:"type guard"})]}),"\n",(0,r.jsxs)(n.h3,{id:"suppressing-any-lint-warnings",children:["Suppressing ",(0,r.jsx)(n.code,{children:"any"})," lint warnings"]}),"\n",(0,r.jsxs)(n.p,{children:["Sometimes using ",(0,r.jsx)(n.code,{children:"any"})," is legitimate, for example in tests to construct a mock object. In such cases, add a comment that suppresses the lint warning, and document why it is legitimate."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// This test only needs a partial implementation of BookService, and if\n// we overlooked something the test will fail in an obvious way.\n// This is an intentionally unsafe partial mock\n// tslint:disable-next-line:no-any\nconst mockBookService = ({get() { return mockBook; }} as any) as BookService;\n// Shopping cart is not used in this test\n// tslint:disable-next-line:no-any\nconst component = new MyComponent(mockBookService, /* unused ShoppingCart */ null as any);\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"-type",children:[(0,r.jsx)(n.code,{children:"{}"})," Type"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"{}"})," type, also known as an empty interface type, represents a interface with no properties. An empty interface type has no specified properties and therefore any non-nullish value is assignable to it."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"let player: {};\nplayer = {\n  health: 50,\n}; // Allowed.\nconsole.log(player.health) // Property 'health' does not exist on type '{}'.\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function takeAnything(obj:{}) {\n}\ntakeAnything({});\ntakeAnything({ a: 1, b: 2 });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Google3 code should not use ",(0,r.jsx)(n.code,{children:"{}"})," for most use cases. ",(0,r.jsx)(n.code,{children:"{}"})," represents any non-nullish primitive or object type, which is rarely appropriate. Prefer one of the following more-descriptive types:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"unknown"})," can hold any value, including ",(0,r.jsx)(n.code,{children:"null"})," or ",(0,r.jsx)(n.code,{children:"undefined"}),", and is generally more appropriate for opaque values."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Record<string, T>"})," is better for dictionary-like objects, and provides better type safety by being explicit about the type ",(0,r.jsx)(n.code,{children:"T"})," of contained values (which may itself be ",(0,r.jsx)(n.code,{children:"unknown"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"object"})," excludes primitives as well, leaving only non-nullish functions and objects, but without any other assumptions about what properties may be available."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tuple-types",children:"Tuple types"}),"\n",(0,r.jsx)(n.p,{children:"If you are tempted to create a Pair type, instead use a tuple type:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Pair {\n  first: string;\n  second: string;\n}\nfunction splitInHalf(input: string): Pair {\n  ...\n  return {first: x, second: y};\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function splitInHalf(input: string): [string, string] {\n  ...\n  return [x, y];\n}\n\n// Use it like:\nconst [leftHalf, rightHalf] = splitInHalf('my string');\n"})}),"\n",(0,r.jsx)(n.p,{children:"However, often it's clearer to provide meaningful names for the properties."}),"\n",(0,r.jsxs)(n.p,{children:["If declaring an ",(0,r.jsx)(n.code,{children:"interface"})," is too heavyweight, you can use an inline object literal type:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"function splitHostPort(address: string): {host: string, port: number} {\n  ...\n}\n\n// Use it like:\nconst address = splitHostPort(userAddress);\nuse(address.port);\n\n// You can also get tuple-like behavior using destructuring:\nconst {host, port} = splitHostPort(userAddress);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"wrapper-types",children:"Wrapper types"}),"\n",(0,r.jsx)(n.p,{children:"There are a few types related to JavaScript primitives that should not ever be used:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"String"}),", ",(0,r.jsx)(n.code,{children:"Boolean"}),", and ",(0,r.jsx)(n.code,{children:"Number"})," have slightly different meaning from the corresponding primitive types ",(0,r.jsx)(n.code,{children:"string"}),", ",(0,r.jsx)(n.code,{children:"boolean"}),", and ",(0,r.jsx)(n.code,{children:"number"}),". Always use the lowercase version."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Object"})," has similarities to both ",(0,r.jsx)(n.code,{children:"{}"})," and ",(0,r.jsx)(n.code,{children:"object"}),", but is slightly looser. Use ",(0,r.jsx)(n.code,{children:"{}"})," for a type that include everything except ",(0,r.jsx)(n.code,{children:"null"})," and ",(0,r.jsx)(n.code,{children:"undefined"}),", or lowercase ",(0,r.jsx)(n.code,{children:"object"})," to further exclude the other primitive types (the three mentioned above, plus ",(0,r.jsx)(n.code,{children:"symbol"})," and ",(0,r.jsx)(n.code,{children:"bigint"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Further, never invoke the wrapper types as constructors (with ",(0,r.jsx)(n.code,{children:"new"}),")."]}),"\n",(0,r.jsx)(n.h2,{id:"return-type-only-generics",children:"Return type only generics"}),"\n",(0,r.jsx)(n.p,{children:"Avoid creating APIs that have return type only generics. When working with existing APIs that have return type only generics always explicitly specify the generics."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const r={},i=t.createContext(r);function a(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);