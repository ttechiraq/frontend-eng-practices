"use strict";(self.webpackChunkfrontend_eng_practices=self.webpackChunkfrontend_eng_practices||[]).push([[257],{3037:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"typescript/policies","title":"Policies","description":"Consistency","source":"@site/docs/1-typescript/9-policies.md","sourceDirName":"1-typescript","slug":"/typescript/policies","permalink":"/frontend-eng-practices/typescript/policies","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/1-typescript/9-policies.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Comments and documentation","permalink":"/frontend-eng-practices/typescript/comments-and-documentation"},"next":{"title":"HTML","permalink":"/frontend-eng-practices/category/html"}}');var i=n(4848),o=n(8453);const r={sidebar_position:9},a="Policies",l={},c=[{value:"Consistency",id:"consistency",level:2},{value:"Reformatting existing code",id:"reformatting-existing-code",level:2},{value:"Deprecation",id:"deprecation",level:2},{value:"Generated code: mostly exempt",id:"generated-code-mostly-exempt",level:2},{value:"Style guide goals",id:"style-guide-goals",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"policies",children:"Policies"})}),"\n",(0,i.jsx)(t.h2,{id:"consistency",children:"Consistency"}),"\n",(0,i.jsx)(t.p,{children:"For any style question that isn't settled definitively by this specification, do what the other code in the same file is already doing (be consistent). If that doesn't resolve the question, consider emulating the other files in the same directory."}),"\n",(0,i.jsxs)(t.p,{children:["Brand new files must use Google Style, regardless of the style choices of other files in the same package. When adding new code to a file that is not in Google Style, reformatting the existing code first is recommended, subject to the advice ",(0,i.jsx)(t.a,{href:"#reformatting-existing-code",children:"below"}),". If this reformatting is not done, then new code should be as consistent as possible with existing code in the same file, but must not violate the style guide."]}),"\n",(0,i.jsx)(t.h2,{id:"reformatting-existing-code",children:"Reformatting existing code"}),"\n",(0,i.jsx)(t.p,{children:"You will occasionally encounter files in the codebase that are not in proper Google Style. These may have come from an acquisition, or may have been written before Google Style took a position on some issue, or may be in non-Google Style for any other reason."}),"\n",(0,i.jsx)(t.p,{children:"When updating the style of existing code, follow these guidelines."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"It is not required to change all existing code to meet current style guidelines. Reformatting existing code is a trade-off between code churn and consistency. Style rules evolve over time and these kinds of tweaks to maintain compliance would create unnecessary churn. However, if significant changes are being made to a file it is expected that the file will be in Google Style."}),"\n",(0,i.jsx)(t.li,{children:"Be careful not to allow opportunistic style fixes to muddle the focus of a CL. If you find yourself making a lot of style changes that aren't critical to the central focus of a CL, promote those changes to a separate CL."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"deprecation",children:"Deprecation"}),"\n",(0,i.jsxs)(t.p,{children:["Mark deprecated methods, classes or interfaces with an ",(0,i.jsx)(t.code,{children:"@deprecated"})," JSDoc annotation. A deprecation comment must include simple, clear directions for people to fix their call sites."]}),"\n",(0,i.jsx)(t.h2,{id:"generated-code-mostly-exempt",children:"Generated code: mostly exempt"}),"\n",(0,i.jsx)(t.p,{children:"Source code generated by the build process is not required to be in Google Style. However, any generated identifiers that will be referenced from hand-written source code must follow the naming requirements. As a special exception, such identifiers are allowed to contain underscores, which may help to avoid conflicts with hand-written identifiers."}),"\n",(0,i.jsx)(t.h2,{id:"style-guide-goals",children:"Style guide goals"}),"\n",(0,i.jsx)(t.p,{children:'In general, engineers usually know best about what\'s needed in their code, so if there are multiple options and the choice is situation dependent, we should let decisions be made locally. So the default answer should be "leave it out".'}),"\n",(0,i.jsx)(t.p,{children:"The following points are the exceptions, which are the reasons we have some global rules. Evaluate your style guide proposal against the following:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Code should avoid patterns that are known to cause problems, especially for users new to the language."})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Code across projects should be consistent across irrelevant variations."})}),"\n",(0,i.jsx)(t.p,{children:"When there are two options that are equivalent in a superficial way, we should consider choosing one just so we don't divergently evolve for no reason and avoid pointless debates in code reviews."}),"\n",(0,i.jsx)(t.p,{children:"Examples:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The capitalization style of names."}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"x as T"})," syntax vs the equivalent ",(0,i.jsx)(t.code,{children:"<T>x"})," syntax (disallowed)."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"Array<[number, number]>"})," vs ",(0,i.jsx)(t.code,{children:"[number, number][]"}),"."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Code should be maintainable in the long term."})}),"\n",(0,i.jsx)(t.p,{children:"Code usually lives longer than the original author works on it, and the TypeScript team must keep all of Google working into the future."}),"\n",(0,i.jsx)(t.p,{children:"Examples:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"We use software to automate changes to code, so code is autoformatted so it's easy for software to meet whitespace rules."}),"\n",(0,i.jsx)(t.li,{children:"We require a single set of compiler flags, so a given TS library can be written assuming a specific set of flags, and users can always safely use a shared library."}),"\n",(0,i.jsxs)(t.li,{children:["Code must import the libraries it uses (",(0,i.jsx)(t.code,{children:"strict deps"}),") so that a refactor in a dependency doesn't change the dependencies of its users."]}),"\n",(0,i.jsx)(t.li,{children:"We ask users to write tests. Without tests we cannot have confidence that changes that we make to the language, don't break users."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Code reviewers should be focused on improving the quality of the code, not enforcing arbitrary rules."})}),"\n",(0,i.jsx)(t.p,{children:"If it's possible to implement your rule as an automated check that is often a good sign. This also supports principle 3."}),"\n",(0,i.jsx)(t.p,{children:"If it really just doesn't matter that much -- if it's an obscure corner of the language or if it avoids a bug that is unlikely to occur -- it's probably worth leaving out."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);