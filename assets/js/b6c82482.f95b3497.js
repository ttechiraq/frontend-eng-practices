"use strict";(self.webpackChunkfrontend_eng_practices=self.webpackChunkfrontend_eng_practices||[]).push([[238],{8275:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"typescript/source-file-structure","title":"Source file structure","description":"Files consist of the following, in order:","source":"@site/docs/1-typescript/3-source-file-structure.md","sourceDirName":"1-typescript","slug":"/typescript/source-file-structure","permalink":"/frontend-eng-practices/typescript/source-file-structure","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/1-typescript/3-source-file-structure.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Source file basics","permalink":"/frontend-eng-practices/typescript/source-file-basics"},"next":{"title":"Language features","permalink":"/frontend-eng-practices/typescript/language-features"}}');var i=t(4848),s=t(8453);const o={sidebar_position:3},a="Source file structure",d={},l=[{value:"Copyright information",id:"copyright-information",level:2},{value:"<code>@fileoverview</code> JSDoc",id:"fileoverview-jsdoc",level:2},{value:"Imports",id:"imports",level:2},{value:"Import paths",id:"import-paths",level:3},{value:"Namespace versus named imports",id:"namespace-versus-named-imports",level:3},{value:"Renaming imports",id:"renaming-imports",level:3},{value:"Exports",id:"exports",level:2},{value:"Import and export type",id:"import-and-export-type",level:2}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"source-file-structure",children:"Source file structure"})}),"\n",(0,i.jsx)(n.p,{children:"Files consist of the following, in order:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Copyright information, if present"}),"\n",(0,i.jsxs)(n.li,{children:["JSDoc with ",(0,i.jsx)(n.code,{children:"@fileoverview"}),", if present"]}),"\n",(0,i.jsx)(n.li,{children:"Imports, if present"}),"\n",(0,i.jsx)(n.li,{children:"The file\u2019s implementation"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Exactly one blank line"})," separates each section that is present."]}),"\n",(0,i.jsx)(n.h2,{id:"copyright-information",children:"Copyright information"}),"\n",(0,i.jsx)(n.p,{children:"If license or copyright information is necessary in a file, add it in a JSDoc at the top of the file."}),"\n",(0,i.jsxs)(n.h2,{id:"fileoverview-jsdoc",children:[(0,i.jsx)(n.code,{children:"@fileoverview"})," JSDoc"]}),"\n",(0,i.jsxs)(n.p,{children:["A file may have a top-level ",(0,i.jsx)(n.code,{children:"@fileoverview JSDoc"}),". If present, it may provide a description of the file's content, its uses, or information about its dependencies. Wrapped lines are not indented."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"/**\n * @fileoverview Description of file. Lorem ipsum dolor sit amet, consectetur\n * adipiscing elit, sed do eiusmod tempor incididunt.\n */\n"})}),"\n",(0,i.jsx)(n.h2,{id:"imports",children:"Imports"}),"\n",(0,i.jsx)(n.p,{children:"There are four variants of import statements in ES6 and TypeScript:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Import type"}),(0,i.jsx)(n.th,{children:"Example"}),(0,i.jsx)(n.th,{children:"Use for"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"module[module_import]"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"import \\* as foo from '...';"})}),(0,i.jsx)(n.td,{children:"TypeScript imports"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"named[destructuring_import]"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"import {SomeThing} from '...';"})}),(0,i.jsx)(n.td,{children:"TypeScript imports"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"default"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"import SomeThing from '...';"})}),(0,i.jsx)(n.td,{children:"Only for other external code that requires them"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"side-effect"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"import '...';"})}),(0,i.jsx)(n.td,{children:"Only to import libraries for their side-effects on load (such as custom elements)"})]})]})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// Good: choose between two options as appropriate (see below).\nimport * as ng from "@angular/core";\nimport { Foo } from "./foo";\n\n// Only when needed: default imports.\nimport Button from "Button";\n\n// Sometimes needed to import libraries for their side effects:\nimport "jasmine";\nimport "@polymer/paper-button";\n'})}),"\n",(0,i.jsx)(n.h3,{id:"import-paths",children:"Import paths"}),"\n",(0,i.jsxs)(n.p,{children:["TypeScript code must use paths to import other TypeScript code. Paths may be relative, i.e. starting with ",(0,i.jsx)(n.code,{children:"."})," or ",(0,i.jsx)(n.code,{children:"..,"})," or rooted at the base directory, e.g. ",(0,i.jsx)(n.code,{children:"root/path/to/file"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Code should use relative imports (",(0,i.jsx)(n.code,{children:"./foo"}),") rather than absolute imports ",(0,i.jsx)(n.code,{children:"path/to/foo"})," when referring to files within the same (logical) project as this allows to move the project around without introducing changes in these imports."]}),"\n",(0,i.jsxs)(n.p,{children:["Consider limiting the number of parent steps (",(0,i.jsx)(n.code,{children:"../../../"}),") as those can make module and path structures hard to understand."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { Symbol1 } from "path/from/root";\nimport { Symbol2 } from "../parent/file";\nimport { Symbol3 } from "./sibling";\n'})}),"\n",(0,i.jsx)(n.h3,{id:"namespace-versus-named-imports",children:"Namespace versus named imports"}),"\n",(0,i.jsx)(n.p,{children:"Both namespace and named imports can be used."}),"\n",(0,i.jsxs)(n.p,{children:["Prefer named imports for symbols used frequently in a file or for symbols that have clear names, for example Jasmine's ",(0,i.jsx)(n.code,{children:"describe"})," and ",(0,i.jsx)(n.code,{children:"it"}),". Named imports can be aliased to clearer names as needed with ",(0,i.jsx)(n.code,{children:"as"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Prefer namespace imports when using many different symbols from large APIs. A namespace import, despite using the ",(0,i.jsx)(n.code,{children:"*"})," character, is not comparable to a wildcard import as seen in other languages. Instead, namespace imports give a name to all the exports of a module, and each exported symbol from the module becomes a property on the module name. Namespace imports can aid readability for exported symbols that have common names like ",(0,i.jsx)(n.code,{children:"Model"})," or ",(0,i.jsx)(n.code,{children:"Controller"})," without the need to declare aliases."]}),"\n",(0,i.jsx)(n.admonition,{title:"bad",type:"warning",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// Bad: overlong import statement of needlessly namespaced names.\nimport {\n  Item as TableviewItem,\n  Header as TableviewHeader,\n  Row as TableviewRow,\n  Model as TableviewModel,\n  Renderer as TableviewRenderer,\n} from "./tableview";\n\nlet item: TableviewItem | undefined;\n'})})}),"\n",(0,i.jsx)(n.admonition,{title:"good",type:"tip",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// Better: use the module for namespacing.\nimport * as tableview from "./tableview";\n\nlet item: tableview.Item | undefined;\n'})})}),"\n",(0,i.jsx)(n.admonition,{title:"bad",type:"warning",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import * as testing from "./testing";\n\n// Bad: The module name does not improve readability.\ntesting.describe("foo", () => {\n  testing.it("bar", () => {\n    testing.expect(null).toBeNull();\n    testing.expect(undefined).toBeUndefined();\n  });\n});\n'})})}),"\n",(0,i.jsx)(n.admonition,{title:"good",type:"tip",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// Better: give local names for these common functions.\nimport { describe, it, expect } from "./testing";\n\ndescribe("foo", () => {\n  it("bar", () => {\n    expect(null).toBeNull();\n    expect(undefined).toBeUndefined();\n  });\n});\n'})})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Special case: Apps JSPB protos"})}),"\n",(0,i.jsx)(n.p,{children:"Apps JSPB protos must use named imports, even when it leads to long import lines."}),"\n",(0,i.jsx)(n.p,{children:"This rule exists to aid in build performance and dead code elimination since often .proto files contain many messages that are not all needed together. By leveraging destructured imports the build system can create finer grained dependencies on Apps JSPB messages while preserving the ergonomics of path based imports."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Good: import the exact set of symbols you need from the proto file.\nimport {Foo, Bar} from './foo.proto';\n\nfunction copyFooBar(foo: Foo, bar: Bar) {...}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"renaming-imports",children:"Renaming imports"}),"\n",(0,i.jsxs)(n.p,{children:["Renaming imports\nCode should fix name collisions by using a namespace import or renaming the exports themselves. Code may rename imports (",(0,i.jsx)(n.code,{children:"import {SomeThing as SomeOtherThing}"}),") if needed."]}),"\n",(0,i.jsx)(n.p,{children:"Three examples where renaming can be helpful:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"If it's necessary to avoid collisions with other imported symbols."}),"\n",(0,i.jsx)(n.li,{children:"If the imported symbol name is generated."}),"\n",(0,i.jsxs)(n.li,{children:["If importing symbols whose names are unclear by themselves, renaming can improve code clarity. For example, when using RxJS the ",(0,i.jsx)(n.code,{children:"from"})," function might be more readable when renamed to ",(0,i.jsx)(n.code,{children:"observableFrom"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"exports",children:"Exports"}),"\n",(0,i.jsx)(n.h2,{id:"import-and-export-type",children:"Import and export type"})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(6540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);