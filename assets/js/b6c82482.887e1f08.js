"use strict";(self.webpackChunkfrontend_eng_practices=self.webpackChunkfrontend_eng_practices||[]).push([[238],{8275:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"typescript/source-file-structure","title":"Source file structure","description":"Files consist of the following, in order:","source":"@site/docs/1-typescript/3-source-file-structure.md","sourceDirName":"1-typescript","slug":"/typescript/source-file-structure","permalink":"/frontend-eng-practices/typescript/source-file-structure","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/1-typescript/3-source-file-structure.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Source file basics","permalink":"/frontend-eng-practices/typescript/source-file-basics"},"next":{"title":"Language features","permalink":"/frontend-eng-practices/typescript/language-features"}}');var o=t(4848),r=t(8453);const i={sidebar_position:3},a="Source file structure",l={},d=[{value:"Copyright information",id:"copyright-information",level:2},{value:"<code>@fileoverview</code> JSDoc",id:"fileoverview-jsdoc",level:2},{value:"Imports",id:"imports",level:2},{value:"Import paths",id:"import-paths",level:3},{value:"Namespace versus named imports",id:"namespace-versus-named-imports",level:3},{value:"Renaming imports",id:"renaming-imports",level:3},{value:"Exports",id:"exports",level:2},{value:"Export visibility",id:"export-visibility",level:3},{value:"Mutable exports",id:"mutable-exports",level:3},{value:"Container classes",id:"container-classes",level:3},{value:"Import and export type",id:"import-and-export-type",level:2},{value:"Import type",id:"import-type",level:3},{value:"Export type",id:"export-type",level:3},{value:"Use modules not namespaces",id:"use-modules-not-namespaces",level:3}];function c(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"source-file-structure",children:"Source file structure"})}),"\n",(0,o.jsx)(n.p,{children:"Files consist of the following, in order:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Copyright information, if present"}),"\n",(0,o.jsxs)(n.li,{children:["JSDoc with ",(0,o.jsx)(n.code,{children:"@fileoverview"}),", if present"]}),"\n",(0,o.jsx)(n.li,{children:"Imports, if present"}),"\n",(0,o.jsx)(n.li,{children:"The file\u2019s implementation"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Exactly one blank line"})," separates each section that is present."]}),"\n",(0,o.jsx)(n.h2,{id:"copyright-information",children:"Copyright information"}),"\n",(0,o.jsx)(n.p,{children:"If license or copyright information is necessary in a file, add it in a JSDoc at the top of the file."}),"\n",(0,o.jsxs)(n.h2,{id:"fileoverview-jsdoc",children:[(0,o.jsx)(n.code,{children:"@fileoverview"})," JSDoc"]}),"\n",(0,o.jsxs)(n.p,{children:["A file may have a top-level ",(0,o.jsx)(n.code,{children:"@fileoverview JSDoc"}),". If present, it may provide a description of the file's content, its uses, or information about its dependencies. Wrapped lines are not indented."]}),"\n",(0,o.jsx)(n.p,{children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"/**\n * @fileoverview Description of file. Lorem ipsum dolor sit amet, consectetur\n * adipiscing elit, sed do eiusmod tempor incididunt.\n */\n"})}),"\n",(0,o.jsx)(n.h2,{id:"imports",children:"Imports"}),"\n",(0,o.jsx)(n.p,{children:"There are four variants of import statements in ES6 and TypeScript:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Import type"}),(0,o.jsx)(n.th,{children:"Example"}),(0,o.jsx)(n.th,{children:"Use for"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"module[module_import]"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"import \\* as foo from '...';"})}),(0,o.jsx)(n.td,{children:"TypeScript imports"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"named[destructuring_import]"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"import {SomeThing} from '...';"})}),(0,o.jsx)(n.td,{children:"TypeScript imports"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"default"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"import SomeThing from '...';"})}),(0,o.jsx)(n.td,{children:"Only for other external code that requires them"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"side-effect"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"import '...';"})}),(0,o.jsx)(n.td,{children:"Only to import libraries for their side-effects on load (such as custom elements)"})]})]})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'// Good: choose between two options as appropriate (see below).\nimport * as ng from "@angular/core";\nimport { Foo } from "./foo";\n\n// Only when needed: default imports.\nimport Button from "Button";\n\n// Sometimes needed to import libraries for their side effects:\nimport "jasmine";\nimport "@polymer/paper-button";\n'})}),"\n",(0,o.jsx)(n.h3,{id:"import-paths",children:"Import paths"}),"\n",(0,o.jsxs)(n.p,{children:["TypeScript code must use paths to import other TypeScript code. Paths may be relative, i.e. starting with ",(0,o.jsx)(n.code,{children:"."})," or ",(0,o.jsx)(n.code,{children:"..,"})," or rooted at the base directory, e.g. ",(0,o.jsx)(n.code,{children:"root/path/to/file"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Code should use relative imports (",(0,o.jsx)(n.code,{children:"./foo"}),") rather than absolute imports ",(0,o.jsx)(n.code,{children:"path/to/foo"})," when referring to files within the same (logical) project as this allows to move the project around without introducing changes in these imports."]}),"\n",(0,o.jsxs)(n.p,{children:["Consider limiting the number of parent steps (",(0,o.jsx)(n.code,{children:"../../../"}),") as those can make module and path structures hard to understand."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { Symbol1 } from "path/from/root";\nimport { Symbol2 } from "../parent/file";\nimport { Symbol3 } from "./sibling";\n'})}),"\n",(0,o.jsx)(n.h3,{id:"namespace-versus-named-imports",children:"Namespace versus named imports"}),"\n",(0,o.jsx)(n.p,{children:"Both namespace and named imports can be used."}),"\n",(0,o.jsxs)(n.p,{children:["Prefer named imports for symbols used frequently in a file or for symbols that have clear names, for example Jasmine's ",(0,o.jsx)(n.code,{children:"describe"})," and ",(0,o.jsx)(n.code,{children:"it"}),". Named imports can be aliased to clearer names as needed with ",(0,o.jsx)(n.code,{children:"as"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Prefer namespace imports when using many different symbols from large APIs. A namespace import, despite using the ",(0,o.jsx)(n.code,{children:"*"})," character, is not comparable to a wildcard import as seen in other languages. Instead, namespace imports give a name to all the exports of a module, and each exported symbol from the module becomes a property on the module name. Namespace imports can aid readability for exported symbols that have common names like ",(0,o.jsx)(n.code,{children:"Model"})," or ",(0,o.jsx)(n.code,{children:"Controller"})," without the need to declare aliases."]}),"\n",(0,o.jsx)(n.admonition,{title:"bad",type:"warning",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'// Bad: overlong import statement of needlessly namespaced names.\nimport {\n  Item as TableviewItem,\n  Header as TableviewHeader,\n  Row as TableviewRow,\n  Model as TableviewModel,\n  Renderer as TableviewRenderer,\n} from "./tableview";\n\nlet item: TableviewItem | undefined;\n'})})}),"\n",(0,o.jsx)(n.admonition,{title:"good",type:"tip",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'// Better: use the module for namespacing.\nimport * as tableview from "./tableview";\n\nlet item: tableview.Item | undefined;\n'})})}),"\n",(0,o.jsx)(n.admonition,{title:"bad",type:"warning",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import * as testing from "./testing";\n\n// Bad: The module name does not improve readability.\ntesting.describe("foo", () => {\n  testing.it("bar", () => {\n    testing.expect(null).toBeNull();\n    testing.expect(undefined).toBeUndefined();\n  });\n});\n'})})}),"\n",(0,o.jsx)(n.admonition,{title:"good",type:"tip",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'// Better: give local names for these common functions.\nimport { describe, it, expect } from "./testing";\n\ndescribe("foo", () => {\n  it("bar", () => {\n    expect(null).toBeNull();\n    expect(undefined).toBeUndefined();\n  });\n});\n'})})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Special case: Apps JSPB protos"})}),"\n",(0,o.jsx)(n.p,{children:"Apps JSPB protos must use named imports, even when it leads to long import lines."}),"\n",(0,o.jsx)(n.p,{children:"This rule exists to aid in build performance and dead code elimination since often .proto files contain many messages that are not all needed together. By leveraging destructured imports the build system can create finer grained dependencies on Apps JSPB messages while preserving the ergonomics of path based imports."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Good: import the exact set of symbols you need from the proto file.\nimport {Foo, Bar} from './foo.proto';\n\nfunction copyFooBar(foo: Foo, bar: Bar) {...}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"renaming-imports",children:"Renaming imports"}),"\n",(0,o.jsxs)(n.p,{children:["Renaming imports\nCode should fix name collisions by using a namespace import or renaming the exports themselves. Code may rename imports (",(0,o.jsx)(n.code,{children:"import {SomeThing as SomeOtherThing}"}),") if needed."]}),"\n",(0,o.jsx)(n.p,{children:"Three examples where renaming can be helpful:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"If it's necessary to avoid collisions with other imported symbols."}),"\n",(0,o.jsx)(n.li,{children:"If the imported symbol name is generated."}),"\n",(0,o.jsxs)(n.li,{children:["If importing symbols whose names are unclear by themselves, renaming can improve code clarity. For example, when using RxJS the ",(0,o.jsx)(n.code,{children:"from"})," function might be more readable when renamed to ",(0,o.jsx)(n.code,{children:"observableFrom"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"exports",children:"Exports"}),"\n",(0,o.jsx)(n.p,{children:"Use named exports in all code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Use named exports:\nexport class Foo { ... }\n"})}),"\n",(0,o.jsx)(n.p,{children:"Do not use default exports. This ensures that all imports follow a uniform pattern."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Do not use default exports:\nexport default class Foo { ... } // BAD!\n"})}),"\n",(0,o.jsx)(n.p,{children:"Why?"}),"\n",(0,o.jsx)(n.p,{children:"Default exports provide no canonical name, which makes central maintenance difficult with relatively little benefit to code owners, including potentially decreased readability:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import Foo from "./bar"; // Legal.\nimport Bar from "./bar"; // Also legal.\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Named exports have the benefit of erroring when import statements try to import something that hasn't been declared. In ",(0,o.jsx)(n.code,{children:"foo.ts"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'const foo = "blah";\nexport default foo;\n'})}),"\n",(0,o.jsxs)(n.p,{children:["And in ",(0,o.jsx)(n.code,{children:"bar.ts"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { fizz } from "./foo";\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Results in ",(0,o.jsx)(n.code,{children:"error TS2614: Module '\"./foo\"' has no exported member 'fizz'"}),". While ",(0,o.jsx)(n.code,{children:"bar.ts"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import fizz from "./foo";\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Results in ",(0,o.jsx)(n.code,{children:"fizz === foo"}),", which is probably unexpected and difficult to debug.\nAdditionally, default exports encourage people to put everything into one big object to namespace it all together:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export default class Foo {\n  static SOME_CONSTANT = ...\n  static someHelpfulFunction() { ... }\n  ...\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["With the above pattern, we have file scope, which can be used as a namespace. We also have a perhaps needless second scope (the class ",(0,o.jsx)(n.code,{children:"Foo"}),") that can be ambiguously used as both a type and a value in other files."]}),"\n",(0,o.jsx)(n.p,{children:"Instead, prefer use of file scope for namespacing, as well as named exports:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export const SOME_CONSTANT = ...\nexport function someHelpfulFunction()\nexport class Foo {\n  // only class stuff here\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"export-visibility",children:"Export visibility"}),"\n",(0,o.jsx)(n.p,{children:"TypeScript does not support restricting the visibility for exported symbols. Only export symbols that are used outside of the module. Generally minimize the exported API surface of modules."}),"\n",(0,o.jsx)(n.h3,{id:"mutable-exports",children:"Mutable exports"}),"\n",(0,o.jsxs)(n.p,{children:["Regardless of technical support, mutable exports can create hard to understand and debug code, in particular with re-exports across multiple modules. One way to paraphrase this style point is that ",(0,o.jsx)(n.code,{children:"export let"})," is not allowed."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export let foo = 3;\n// In pure ES6, foo is mutable and importers will observe the value change after a second.\n// In TS, if foo is re-exported by a second file, importers will not see the value change.\nwindow.setTimeout(() => {\n  foo = 4;\n}, 1000 /* ms */);\n"})}),"\n",(0,o.jsx)(n.p,{children:"If one needs to support externally accessible and mutable bindings, they should instead use explicit getter functions."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"let foo = 3;\nwindow.setTimeout(() => {\n  foo = 4;\n}, 1000 /* ms */);\n// Use an explicit getter to access the mutable export.\nexport function getFoo() {\n  return foo;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"For the common pattern of conditionally exporting either of two values, first do the conditional check, then the export. Make sure that all exports are final after the module's body has executed."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function pickApi() {\n  if (useOtherApi()) return OtherApi;\n  return RegularApi;\n}\nexport const SomeApi = pickApi();\n"})}),"\n",(0,o.jsx)(n.h3,{id:"container-classes",children:"Container classes"}),"\n",(0,o.jsx)(n.p,{children:"Do not create container classes with static methods or properties for the sake of namespacing."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export class Container {\n  static FOO = 1;\n  static bar() {\n    return 1;\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Instead, export individual constants and functions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"export const FOO = 1;\nexport function bar() {\n  return 1;\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"import-and-export-type",children:"Import and export type"}),"\n",(0,o.jsx)(n.h3,{id:"import-type",children:"Import type"}),"\n",(0,o.jsxs)(n.p,{children:["You may use ",(0,o.jsx)(n.code,{children:"import type {...}"})," when you use the imported symbol only as a type. Use regular imports for values:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import type { Foo } from "./foo";\nimport { Bar } from "./foo";\n\nimport { type Foo, Bar } from "./foo";\n'})}),"\n",(0,o.jsx)(n.p,{children:"Why?"}),"\n",(0,o.jsx)(n.p,{children:"The TypeScript compiler automatically handles the distinction and does not insert runtime loads for type references. So why annotate type imports?"}),"\n",(0,o.jsx)(n.p,{children:"The TypeScript compiler can run in 2 modes:"}),"\n",(0,o.jsxs)(n.p,{children:["In development mode, we typically want quick iteration loops. The compiler transpiles to JavaScript without full type information. This is much faster, but requires ",(0,o.jsx)(n.code,{children:"import type"})," in certain cases.\nIn production mode, we want correctness. The compiler type checks everything and ensures ",(0,o.jsx)(n.code,{children:"import type"})," is used correctly."]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Note: If you need to force a runtime load for side effects, use ",(0,o.jsx)(n.code,{children:"import '...';"}),". See"]})}),"\n",(0,o.jsx)(n.h3,{id:"export-type",children:"Export type"}),"\n",(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"export type"})," when re-exporting a type, e.g.:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'export type { AnInterface } from "./foo";\n'})}),"\n",(0,o.jsx)(n.p,{children:"Why?"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"export type"})," is useful to allow type re-exports in file-by-file transpilation. See isolatedModules docs."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"export type"})," might also seem useful to avoid ever exporting a value symbol for an API. However it does not give guarantees, either: downstream code might still import an API through a different path. A better way to split & guarantee type vs value usages of an API is to actually split the symbols into e.g. ",(0,o.jsx)(n.code,{children:"UserService"})," and ",(0,o.jsx)(n.code,{children:"AjaxUserService"}),". This is less error prone and also better communicates intent."]}),"\n",(0,o.jsx)(n.h3,{id:"use-modules-not-namespaces",children:"Use modules not namespaces"}),"\n",(0,o.jsxs)(n.p,{children:["TypeScript supports two methods to organize code: namespaces and modules, but namespaces are disallowed. That is, your code must refer to code in other files using imports and exports of the form ",(0,o.jsx)(n.code,{children:"import {foo} from 'bar';"})]}),"\n",(0,o.jsxs)(n.p,{children:["Your code must not use the ",(0,o.jsx)(n.code,{children:"namespace Foo { ... }"})," construct. ",(0,o.jsx)(n.code,{children:"namespaces"})," may only be used when required to interface with external, third party code. To semantically namespace your code, use separate files."]}),"\n",(0,o.jsxs)(n.p,{children:["Code must not use ",(0,o.jsx)(n.code,{children:"require"})," (as in ",(0,o.jsx)(n.code,{children:"import x = require('...');"}),") for imports. Use ES6 module syntax."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Bad: do not use namespaces:\nnamespace Rocket {\n  function launch() { ... }\n}\n\n// Bad: do not use <reference>\n/// <reference path=\"...\"/>\n\n// Bad: do not use require()\nimport x = require('mydep');\n"})}),"\n",(0,o.jsxs)(n.p,{children:["NB: TypeScript ",(0,o.jsx)(n.code,{children:"namespaces"})," used to be called internal ",(0,o.jsx)(n.code,{children:"modules"})," and used to use the module keyword in the form ",(0,o.jsx)(n.code,{children:"module Foo { ... }"}),". Don't use that either. Always use ES6 imports."]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(6540);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);